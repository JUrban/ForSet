(** A few extra results not in the Egal library from 2014 **)

Section Eq.

Variable A B:SType.

Theorem f_equal : forall f:A -> B, forall x y:A, x = y -> f x = f y.
let f x y. assume Hxy. rewrite <- Hxy. apply eqI B.
Qed.

End Eq.

Definition bij : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall u v :e X, f u = f v -> u = v)
  /\
  (forall w :e Y, exists u :e X, f u = w).

Definition inv : set -> (set -> set) -> set -> set := fun X f => fun y:set => some x :e X, f x = y.

Theorem surj_rinv : forall X Y, forall f:set->set, (forall w :e Y, exists u :e X, f u = w) -> forall y :e Y, inv X f y :e X /\ f (inv X f y) = y.
let X Y f. assume H1.
let y. assume Hy: y :e Y.
apply H1 y Hy.
let x.
assume H2.
exact EpsR set (fun x => x :e X /\ f x = y) x H2.
Qed.

Theorem inj_linv : forall X Y, forall f:set->set, (forall u v :e X, f u = f v -> u = v) -> forall x :e X, inv X f (f x) = x.
let X Y f.
assume H1.
let x. assume Hx.
claim L1: inv X f (f x) :e X /\ f (inv X f (f x)) = f x.
{ apply EpsR set (fun x' => x' :e X /\ f x' = f x) x.
  apply andI.
  - exact Hx.
  - exact eqI set (f x).
}
apply L1.
assume H2 H3.
exact H1 (inv X f (f x)) H2 x Hx H3.
Qed.

Theorem bij_inv : forall X Y, forall f:set->set, bij X Y f -> bij Y X (inv X f).
let X Y f.
assume H1. apply H1.
assume H2. apply H2.
assume H3: forall u :e X, f u :e Y.
assume H4: forall u v :e X, f u = f v -> u = v.
assume H5: forall w :e Y, exists u :e X, f u = w.
set g : set->set := fun y => some x :e X, f x = y.
claim L1: forall y :e Y, g y :e X /\ f (g y) = y.
{ exact surj_rinv X Y f H5. }
prove (forall u :e Y, g u :e X)
      /\
      (forall u v :e Y, g u = g v -> u = v)
      /\
      (forall w :e X, exists u :e Y, g u = w).
apply and3I.
- prove forall u :e Y, g u :e X.
  let u. assume Hu. apply L1 u Hu. assume H _. exact H.
- prove forall u v :e Y, g u = g v -> u = v.
  let u. assume Hu. let v. assume Hv H6.
  prove u = v.
  apply L1 u Hu.
  assume H7: g u :e X.
  assume H8: f (g u) = u.
  apply L1 v Hv.
  assume H9: g v :e X.
  assume H10: f (g v) = v.
  rewrite <- H8.
  rewrite <- H10.
  rewrite <- H6.
  apply eqI set.
- prove forall w :e X, exists u :e Y, g u = w.
  let w. assume Hw.
  claim Lfw: f w :e Y.
  { exact H3 w Hw. }
  witness f w.
  apply andI.
  + exact Lfw.
  + exact inj_linv X Y f H4 w Hw.
Qed.

Theorem bij_comp : forall X Y Z:set, forall f g:set->set, bij X Y f -> bij Y Z g -> bij X Z (fun x => g (f x)).
let X Y Z f g.
assume Hf. apply Hf. assume Hf12 Hf3. apply Hf12. assume Hf1 Hf2.
assume Hg. apply Hg. assume Hg12 Hg3. apply Hg12. assume Hg1 Hg2.
prove (forall u :e X, g (f u) :e Z)
  /\
  (forall u v :e X, g (f u) = g (f v) -> u = v)
  /\
  (forall w :e Z, exists u :e X, g (f u) = w).
apply and3I.
- let u. assume Hu: u :e X. exact (Hg1 (f u) (Hf1 u Hu)).
- let u. assume Hu: u :e X. let v. assume Hv: v :e X.
  assume H1: g (f u) = g (f v).
  prove u = v.
  apply Hf2 u Hu v Hv.
  prove f u = f v.
  apply Hg2 (f u) (Hf1 u Hu) (f v) (Hf1 v Hv).
  prove g (f u) = g (f v).
  exact H1.
- let w. assume Hw: w :e Z. apply Hg3 w Hw.
  let y. assume Hy12. apply Hy12.
  assume Hy1: y :e Y. assume Hy2: g y = w.
  apply Hf3 y Hy1.
  let u. assume Hu12. apply Hu12.
  assume Hu1: u :e X. assume Hu2: f u = y.
  prove exists u :e X, g (f u) = w.
  witness u.
  apply andI.
  + exact Hu1.
  + rewrite Hu2. exact Hy2.
Qed.

Theorem bij_id : forall X, bij X X (fun x => x).
let X.
prove (forall u :e X, u :e X) /\ (forall u v :e X, u = v -> u = v) /\ (forall w :e X, exists u :e X, u = w).
apply and3I.
- exact (fun u Hu => Hu).
- exact (fun u Hu v Hv H1 => H1).
- let w. assume Hw. witness w. apply andI.
  + exact Hw.
  + apply eqI set.
Qed.

Theorem and6I: forall P1 P2 P3 P4 P5 P6:prop, P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6.
let P1 P2 P3 P4 P5 P6.
assume H1 H2 H3 H4 H5 H6.
apply and5I.
- apply andI.
  + exact H1.
  + exact H2.
- exact H3.
- exact H4.
- exact H5.
- exact H6.
Qed.

Theorem and7I: forall P1 P2 P3 P4 P5 P6 P7:prop, P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7.
let P1 P2 P3 P4 P5 P6 P7.
assume H1 H2 H3 H4 H5 H6 H7.
apply and6I.
- apply andI.
  + exact H1.
  + exact H2.
- exact H3.
- exact H4.
- exact H5.
- exact H6.
- exact H7.
Qed.

Theorem In_0_3: 0 :e 3.
exact ordsuccI1 2 0 In_0_2.
Qed.

Theorem In_1_3: 1 :e 3.
exact ordsuccI1 2 1 In_1_2.
Qed.

Theorem In_2_3: 2 :e 3.
exact ordsuccI2 2.
Qed.

Theorem In_0_4: 0 :e 4.
exact ordsuccI1 3 0 In_0_3.
Qed.

Theorem In_1_4: 1 :e 4.
exact ordsuccI1 3 1 In_1_3.
Qed.

Theorem In_2_4: 2 :e 4.
exact ordsuccI1 3 2 In_2_3.
Qed.

Theorem In_3_4: 3 :e 4.
exact ordsuccI2 3.
Qed.

Theorem In_0_5: 0 :e 5.
exact ordsuccI1 4 0 In_0_4.
Qed.

Theorem In_1_5: 1 :e 5.
exact ordsuccI1 4 1 In_1_4.
Qed.

Theorem In_2_5: 2 :e 5.
exact ordsuccI1 4 2 In_2_4.
Qed.

Theorem In_3_5: 3 :e 5.
exact ordsuccI1 4 3 In_3_4.
Qed.

Theorem In_4_5: 4 :e 5.
exact ordsuccI2 4.
Qed.

Theorem In_0_6: 0 :e 6.
exact ordsuccI1 5 0 In_0_5.
Qed.

Theorem In_1_6: 1 :e 6.
exact ordsuccI1 5 1 In_1_5.
Qed.

Theorem In_2_6: 2 :e 6.
exact ordsuccI1 5 2 In_2_5.
Qed.

Theorem In_3_6: 3 :e 6.
exact ordsuccI1 5 3 In_3_5.
Qed.

Theorem In_4_6: 4 :e 6.
exact ordsuccI1 5 4 In_4_5.
Qed.

Theorem In_5_6: 5 :e 6.
exact ordsuccI2 5.
Qed.

Theorem In_0_7: 0 :e 7.
exact ordsuccI1 6 0 In_0_6.
Qed.

Theorem In_1_7: 1 :e 7.
exact ordsuccI1 6 1 In_1_6.
Qed.

Theorem In_2_7: 2 :e 7.
exact ordsuccI1 6 2 In_2_6.
Qed.

Theorem In_3_7: 3 :e 7.
exact ordsuccI1 6 3 In_3_6.
Qed.

Theorem In_4_7: 4 :e 7.
exact ordsuccI1 6 4 In_4_6.
Qed.

Theorem In_5_7: 5 :e 7.
exact ordsuccI1 6 5 In_5_6.
Qed.

Theorem In_6_7: 6 :e 7.
exact ordsuccI2 6.
Qed.

Theorem In_0_8: 0 :e 8.
exact ordsuccI1 7 0 In_0_7.
Qed.

Theorem In_1_8: 1 :e 8.
exact ordsuccI1 7 1 In_1_7.
Qed.

Theorem In_2_8: 2 :e 8.
exact ordsuccI1 7 2 In_2_7.
Qed.

Theorem In_3_8: 3 :e 8.
exact ordsuccI1 7 3 In_3_7.
Qed.

Theorem In_4_8: 4 :e 8.
exact ordsuccI1 7 4 In_4_7.
Qed.

Theorem In_5_8: 5 :e 8.
exact ordsuccI1 7 5 In_5_7.
Qed.

Theorem In_6_8: 6 :e 8.
exact ordsuccI1 7 6 In_6_7.
Qed.

Theorem In_7_8: 7 :e 8.
exact ordsuccI2 7.
Qed.

Theorem In_0_9: 0 :e 9.
exact ordsuccI1 8 0 In_0_8.
Qed.

Theorem In_1_9: 1 :e 9.
exact ordsuccI1 8 1 In_1_8.
Qed.

Theorem In_2_9: 2 :e 9.
exact ordsuccI1 8 2 In_2_8.
Qed.

Theorem In_3_9: 3 :e 9.
exact ordsuccI1 8 3 In_3_8.
Qed.

Theorem In_4_9: 4 :e 9.
exact ordsuccI1 8 4 In_4_8.
Qed.

Theorem In_5_9: 5 :e 9.
exact ordsuccI1 8 5 In_5_8.
Qed.

Theorem In_6_9: 6 :e 9.
exact ordsuccI1 8 6 In_6_8.
Qed.

Theorem In_7_9: 7 :e 9.
exact ordsuccI1 8 7 In_7_8.
Qed.

Theorem In_8_9: 8 :e 9.
exact ordsuccI2 8.
Qed.

Theorem cases_1: forall i :e 1, forall p:set->prop, p 0 -> p i.
let i. assume Hi. let p. assume Hp0.
apply ordsuccE 0 i Hi.
- assume Hil: i :e 0.
  apply EmptyE i Hil.
- assume Hie: i = 0.
  rewrite Hie. exact Hp0.
Qed.

Theorem cases_2: forall i :e 2, forall p:set->prop, p 0 -> p 1 -> p i.
let i. assume Hi. let p. assume Hp0 Hp1.
apply ordsuccE 1 i Hi.
- assume Hil: i :e 1.
  exact cases_1 i Hil p Hp0.
- assume Hie: i = 1.
  rewrite Hie. exact Hp1.
Qed.

Theorem cases_3: forall i :e 3, forall p:set->prop, p 0 -> p 1 -> p 2 -> p i.
let i. assume Hi. let p. assume Hp0 Hp1 Hp2.
apply ordsuccE 2 i Hi.
- assume Hil: i :e 2.
  exact cases_2 i Hil p Hp0 Hp1.
- assume Hie: i = 2.
  rewrite Hie. exact Hp2.
Qed.

Theorem cases_4: forall i :e 4, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p i.
let i. assume Hi. let p. assume Hp0 Hp1 Hp2 Hp3.
apply ordsuccE 3 i Hi.
- assume Hil: i :e 3.
  exact cases_3 i Hil p Hp0 Hp1 Hp2.
- assume Hie: i = 3.
  rewrite Hie. exact Hp3.
Qed.

Theorem cases_5: forall i :e 5, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p i.
let i. assume Hi. let p. assume Hp0 Hp1 Hp2 Hp3 Hp4.
apply ordsuccE 4 i Hi.
- assume Hil: i :e 4.
  exact cases_4 i Hil p Hp0 Hp1 Hp2 Hp3.
- assume Hie: i = 4.
  rewrite Hie. exact Hp4.
Qed.

Theorem cases_6: forall i :e 6, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p 5 -> p i.
let i. assume Hi. let p. assume Hp0 Hp1 Hp2 Hp3 Hp4 Hp5.
apply ordsuccE 5 i Hi.
- assume Hil: i :e 5.
  exact cases_5 i Hil p Hp0 Hp1 Hp2 Hp3 Hp4.
- assume Hie: i = 5.
  rewrite Hie. exact Hp5.
Qed.

Theorem cases_7: forall i :e 7, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p 5 -> p 6 -> p i.
let i. assume Hi. let p. assume Hp0 Hp1 Hp2 Hp3 Hp4 Hp5 Hp6.
apply ordsuccE 6 i Hi.
- assume Hil: i :e 6.
  exact cases_6 i Hil p Hp0 Hp1 Hp2 Hp3 Hp4 Hp5.
- assume Hie: i = 6.
  rewrite Hie. exact Hp6.
Qed.

Theorem cases_8: forall i :e 8, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p 5 -> p 6 -> p 7 -> p i.
let i. assume Hi. let p. assume Hp0 Hp1 Hp2 Hp3 Hp4 Hp5 Hp6 Hp7.
apply ordsuccE 7 i Hi.
- assume Hil: i :e 7.
  exact cases_7 i Hil p Hp0 Hp1 Hp2 Hp3 Hp4 Hp5 Hp6.
- assume Hie: i = 7.
  rewrite Hie. exact Hp7.
Qed.

Theorem cases_9: forall i :e 9, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p 5 -> p 6 -> p 7 -> p 8 -> p i.
let i. assume Hi. let p. assume Hp0 Hp1 Hp2 Hp3 Hp4 Hp5 Hp6 Hp7 Hp8.
apply ordsuccE 8 i Hi.
- assume Hil: i :e 8.
  exact cases_8 i Hil p Hp0 Hp1 Hp2 Hp3 Hp4 Hp5 Hp6 Hp7.
- assume Hie: i = 8.
  rewrite Hie. exact Hp8.
Qed.

Theorem neq_3_0: 3 <> 0.
apply neq_ordsucc_0.
Qed.

Theorem neq_3_1: 3 <> 1.
apply ordsucc_inj_contra. exact neq_2_0.
Qed.

Theorem neq_3_2: 3 <> 2.
apply ordsucc_inj_contra. exact neq_2_1.
Qed.

Theorem neq_4_0: 4 <> 0.
apply neq_ordsucc_0.
Qed.

Theorem neq_4_1: 4 <> 1.
apply ordsucc_inj_contra. exact neq_3_0.
Qed.

Theorem neq_4_2: 4 <> 2.
apply ordsucc_inj_contra. exact neq_3_1.
Qed.

Theorem neq_4_3: 4 <> 3.
apply ordsucc_inj_contra. exact neq_3_2.
Qed.

Theorem neq_5_0: 5 <> 0.
apply neq_ordsucc_0.
Qed.

Theorem neq_5_1: 5 <> 1.
apply ordsucc_inj_contra. exact neq_4_0.
Qed.

Theorem neq_5_2: 5 <> 2.
apply ordsucc_inj_contra. exact neq_4_1.
Qed.

Theorem neq_5_3: 5 <> 3.
apply ordsucc_inj_contra. exact neq_4_2.
Qed.

Theorem neq_5_4: 5 <> 4.
apply ordsucc_inj_contra. exact neq_4_3.
Qed.

Theorem neq_6_0: 6 <> 0.
apply neq_ordsucc_0.
Qed.

Theorem neq_6_1: 6 <> 1.
apply ordsucc_inj_contra. exact neq_5_0.
Qed.

Theorem neq_6_2: 6 <> 2.
apply ordsucc_inj_contra. exact neq_5_1.
Qed.

Theorem neq_6_3: 6 <> 3.
apply ordsucc_inj_contra. exact neq_5_2.
Qed.

Theorem neq_6_4: 6 <> 4.
apply ordsucc_inj_contra. exact neq_5_3.
Qed.

Theorem neq_6_5: 6 <> 5.
apply ordsucc_inj_contra. exact neq_5_4.
Qed.

Theorem neq_7_0: 7 <> 0.
apply neq_ordsucc_0.
Qed.

Theorem neq_7_1: 7 <> 1.
apply ordsucc_inj_contra. exact neq_6_0.
Qed.

Theorem neq_7_2: 7 <> 2.
apply ordsucc_inj_contra. exact neq_6_1.
Qed.

Theorem neq_7_3: 7 <> 3.
apply ordsucc_inj_contra. exact neq_6_2.
Qed.

Theorem neq_7_4: 7 <> 4.
apply ordsucc_inj_contra. exact neq_6_3.
Qed.

Theorem neq_7_5: 7 <> 5.
apply ordsucc_inj_contra. exact neq_6_4.
Qed.

Theorem neq_7_6: 7 <> 6.
apply ordsucc_inj_contra. exact neq_6_5.
Qed.

Theorem neq_8_0: 8 <> 0.
apply neq_ordsucc_0.
Qed.

Theorem neq_8_1: 8 <> 1.
apply ordsucc_inj_contra. exact neq_7_0.
Qed.

Theorem neq_8_2: 8 <> 2.
apply ordsucc_inj_contra. exact neq_7_1.
Qed.

Theorem neq_8_3: 8 <> 3.
apply ordsucc_inj_contra. exact neq_7_2.
Qed.

Theorem neq_8_4: 8 <> 4.
apply ordsucc_inj_contra. exact neq_7_3.
Qed.

Theorem neq_8_5: 8 <> 5.
apply ordsucc_inj_contra. exact neq_7_4.
Qed.

Theorem neq_8_6: 8 <> 6.
apply ordsucc_inj_contra. exact neq_7_5.
Qed.

Theorem neq_8_7: 8 <> 7.
apply ordsucc_inj_contra. exact neq_7_6.
Qed.

Theorem neq_9_0: 9 <> 0.
apply neq_ordsucc_0.
Qed.

Theorem neq_9_1: 9 <> 1.
apply ordsucc_inj_contra. exact neq_8_0.
Qed.

Theorem neq_9_2: 9 <> 2.
apply ordsucc_inj_contra. exact neq_8_1.
Qed.

Theorem neq_9_3: 9 <> 3.
apply ordsucc_inj_contra. exact neq_8_2.
Qed.

Theorem neq_9_4: 9 <> 4.
apply ordsucc_inj_contra. exact neq_8_3.
Qed.

Theorem neq_9_5: 9 <> 5.
apply ordsucc_inj_contra. exact neq_8_4.
Qed.

Theorem neq_9_6: 9 <> 6.
apply ordsucc_inj_contra. exact neq_8_5.
Qed.

Theorem neq_9_7: 9 <> 7.
apply ordsucc_inj_contra. exact neq_8_6.
Qed.

Theorem neq_9_8: 9 <> 8.
apply ordsucc_inj_contra. exact neq_8_7.
Qed.

Section Tuples.

Variable x0 x1: set.
Theorem tuple_2_0_eq: (x0,x1) 0 = x0.
rewrite beta 2 (fun i => if i = 0 then x0 else x1) 0 In_0_2.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_2_1_eq: (x0,x1) 1 = x1.
rewrite beta 2 (fun i => if i = 0 then x0 else x1) 1 In_1_2.
apply If_0 set. apply neq_1_0.
Qed.

Variable x2: set.
Theorem tuple_3_0_eq: (x0,x1,x2) 0 = x0.
rewrite beta 3 (fun i => if i = 0 then x0 else if i = 1 then x1 else x2) 0 In_0_3.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_3_1_eq: (x0,x1,x2) 1 = x1.
rewrite beta 3 (fun i => if i = 0 then x0 else if i = 1 then x1 else x2) 1 In_1_3.
rewrite If_0 set (1 = 0) x0 (if 1 = 1 then x1 else x2) neq_1_0.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_3_2_eq: (x0,x1,x2) 2 = x2.
rewrite beta 3 (fun i => if i = 0 then x0 else if i = 1 then x1 else x2) 2 In_2_3.
rewrite If_0 set (2 = 0) x0 (if 2 = 1 then x1 else x2) neq_2_0.
apply If_0 set. apply neq_2_1.
Qed.

Variable x3: set.
Theorem tuple_4_0_eq: (x0,x1,x2,x3) 0 = x0.
rewrite beta 4 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else x3) 0 In_0_4.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_4_1_eq: (x0,x1,x2,x3) 1 = x1.
rewrite beta 4 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else x3) 1 In_1_4.
rewrite If_0 set (1 = 0) x0 (if 1 = 1 then x1 else if 1 = 2 then x2 else x3) neq_1_0.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_4_2_eq: (x0,x1,x2,x3) 2 = x2.
rewrite beta 4 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else x3) 2 In_2_4.
rewrite If_0 set (2 = 0) x0 (if 2 = 1 then x1 else if 2 = 2 then x2 else x3) neq_2_0.
rewrite If_0 set (2 = 1) x1 (if 2 = 2 then x2 else x3) neq_2_1.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_4_3_eq: (x0,x1,x2,x3) 3 = x3.
rewrite beta 4 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else x3) 3 In_3_4.
rewrite If_0 set (3 = 0) x0 (if 3 = 1 then x1 else if 3 = 2 then x2 else x3) neq_3_0.
rewrite If_0 set (3 = 1) x1 (if 3 = 2 then x2 else x3) neq_3_1.
apply If_0 set. apply neq_3_2.
Qed.

Variable x4: set.
Theorem tuple_5_0_eq: (x0,x1,x2,x3,x4) 0 = x0.
rewrite beta 5 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else x4) 0 In_0_5.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_5_1_eq: (x0,x1,x2,x3,x4) 1 = x1.
rewrite beta 5 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else x4) 1 In_1_5.
rewrite If_0 set (1 = 0) x0 (if 1 = 1 then x1 else if 1 = 2 then x2 else if 1 = 3 then x3 else x4) neq_1_0.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_5_2_eq: (x0,x1,x2,x3,x4) 2 = x2.
rewrite beta 5 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else x4) 2 In_2_5.
rewrite If_0 set (2 = 0) x0 (if 2 = 1 then x1 else if 2 = 2 then x2 else if 2 = 3 then x3 else x4) neq_2_0.
rewrite If_0 set (2 = 1) x1 (if 2 = 2 then x2 else if 2 = 3 then x3 else x4) neq_2_1.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_5_3_eq: (x0,x1,x2,x3,x4) 3 = x3.
rewrite beta 5 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else x4) 3 In_3_5.
rewrite If_0 set (3 = 0) x0 (if 3 = 1 then x1 else if 3 = 2 then x2 else if 3 = 3 then x3 else x4) neq_3_0.
rewrite If_0 set (3 = 1) x1 (if 3 = 2 then x2 else if 3 = 3 then x3 else x4) neq_3_1.
rewrite If_0 set (3 = 2) x2 (if 3 = 3 then x3 else x4) neq_3_2.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_5_4_eq: (x0,x1,x2,x3,x4) 4 = x4.
rewrite beta 5 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else x4) 4 In_4_5.
rewrite If_0 set (4 = 0) x0 (if 4 = 1 then x1 else if 4 = 2 then x2 else if 4 = 3 then x3 else x4) neq_4_0.
rewrite If_0 set (4 = 1) x1 (if 4 = 2 then x2 else if 4 = 3 then x3 else x4) neq_4_1.
rewrite If_0 set (4 = 2) x2 (if 4 = 3 then x3 else x4) neq_4_2.
apply If_0 set. apply neq_4_3.
Qed.

Variable x5: set.
Theorem tuple_6_0_eq: (x0,x1,x2,x3,x4,x5) 0 = x0.
rewrite beta 6 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else x5) 0 In_0_6.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_6_1_eq: (x0,x1,x2,x3,x4,x5) 1 = x1.
rewrite beta 6 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else x5) 1 In_1_6.
rewrite If_0 set (1 = 0) x0 (if 1 = 1 then x1 else if 1 = 2 then x2 else if 1 = 3 then x3 else if 1 = 4 then x4 else x5) neq_1_0.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_6_2_eq: (x0,x1,x2,x3,x4,x5) 2 = x2.
rewrite beta 6 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else x5) 2 In_2_6.
rewrite If_0 set (2 = 0) x0 (if 2 = 1 then x1 else if 2 = 2 then x2 else if 2 = 3 then x3 else if 2 = 4 then x4 else x5) neq_2_0.
rewrite If_0 set (2 = 1) x1 (if 2 = 2 then x2 else if 2 = 3 then x3 else if 2 = 4 then x4 else x5) neq_2_1.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_6_3_eq: (x0,x1,x2,x3,x4,x5) 3 = x3.
rewrite beta 6 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else x5) 3 In_3_6.
rewrite If_0 set (3 = 0) x0 (if 3 = 1 then x1 else if 3 = 2 then x2 else if 3 = 3 then x3 else if 3 = 4 then x4 else x5) neq_3_0.
rewrite If_0 set (3 = 1) x1 (if 3 = 2 then x2 else if 3 = 3 then x3 else if 3 = 4 then x4 else x5) neq_3_1.
rewrite If_0 set (3 = 2) x2 (if 3 = 3 then x3 else if 3 = 4 then x4 else x5) neq_3_2.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_6_4_eq: (x0,x1,x2,x3,x4,x5) 4 = x4.
rewrite beta 6 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else x5) 4 In_4_6.
rewrite If_0 set (4 = 0) x0 (if 4 = 1 then x1 else if 4 = 2 then x2 else if 4 = 3 then x3 else if 4 = 4 then x4 else x5) neq_4_0.
rewrite If_0 set (4 = 1) x1 (if 4 = 2 then x2 else if 4 = 3 then x3 else if 4 = 4 then x4 else x5) neq_4_1.
rewrite If_0 set (4 = 2) x2 (if 4 = 3 then x3 else if 4 = 4 then x4 else x5) neq_4_2.
rewrite If_0 set (4 = 3) x3 (if 4 = 4 then x4 else x5) neq_4_3.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_6_5_eq: (x0,x1,x2,x3,x4,x5) 5 = x5.
rewrite beta 6 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else x5) 5 In_5_6.
rewrite If_0 set (5 = 0) x0 (if 5 = 1 then x1 else if 5 = 2 then x2 else if 5 = 3 then x3 else if 5 = 4 then x4 else x5) neq_5_0.
rewrite If_0 set (5 = 1) x1 (if 5 = 2 then x2 else if 5 = 3 then x3 else if 5 = 4 then x4 else x5) neq_5_1.
rewrite If_0 set (5 = 2) x2 (if 5 = 3 then x3 else if 5 = 4 then x4 else x5) neq_5_2.
rewrite If_0 set (5 = 3) x3 (if 5 = 4 then x4 else x5) neq_5_3.
apply If_0 set. apply neq_5_4.
Qed.

Variable x6: set.
Theorem tuple_7_0_eq: (x0,x1,x2,x3,x4,x5,x6) 0 = x0.
rewrite beta 7 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else x6) 0 In_0_7.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_7_1_eq: (x0,x1,x2,x3,x4,x5,x6) 1 = x1.
rewrite beta 7 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else x6) 1 In_1_7.
rewrite If_0 set (1 = 0) x0 (if 1 = 1 then x1 else if 1 = 2 then x2 else if 1 = 3 then x3 else if 1 = 4 then x4 else if 1 = 5 then x5 else x6) neq_1_0.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_7_2_eq: (x0,x1,x2,x3,x4,x5,x6) 2 = x2.
rewrite beta 7 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else x6) 2 In_2_7.
rewrite If_0 set (2 = 0) x0 (if 2 = 1 then x1 else if 2 = 2 then x2 else if 2 = 3 then x3 else if 2 = 4 then x4 else if 2 = 5 then x5 else x6) neq_2_0.
rewrite If_0 set (2 = 1) x1 (if 2 = 2 then x2 else if 2 = 3 then x3 else if 2 = 4 then x4 else if 2 = 5 then x5 else x6) neq_2_1.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_7_3_eq: (x0,x1,x2,x3,x4,x5,x6) 3 = x3.
rewrite beta 7 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else x6) 3 In_3_7.
rewrite If_0 set (3 = 0) x0 (if 3 = 1 then x1 else if 3 = 2 then x2 else if 3 = 3 then x3 else if 3 = 4 then x4 else if 3 = 5 then x5 else x6) neq_3_0.
rewrite If_0 set (3 = 1) x1 (if 3 = 2 then x2 else if 3 = 3 then x3 else if 3 = 4 then x4 else if 3 = 5 then x5 else x6) neq_3_1.
rewrite If_0 set (3 = 2) x2 (if 3 = 3 then x3 else if 3 = 4 then x4 else if 3 = 5 then x5 else x6) neq_3_2.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_7_4_eq: (x0,x1,x2,x3,x4,x5,x6) 4 = x4.
rewrite beta 7 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else x6) 4 In_4_7.
rewrite If_0 set (4 = 0) x0 (if 4 = 1 then x1 else if 4 = 2 then x2 else if 4 = 3 then x3 else if 4 = 4 then x4 else if 4 = 5 then x5 else x6) neq_4_0.
rewrite If_0 set (4 = 1) x1 (if 4 = 2 then x2 else if 4 = 3 then x3 else if 4 = 4 then x4 else if 4 = 5 then x5 else x6) neq_4_1.
rewrite If_0 set (4 = 2) x2 (if 4 = 3 then x3 else if 4 = 4 then x4 else if 4 = 5 then x5 else x6) neq_4_2.
rewrite If_0 set (4 = 3) x3 (if 4 = 4 then x4 else if 4 = 5 then x5 else x6) neq_4_3.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_7_5_eq: (x0,x1,x2,x3,x4,x5,x6) 5 = x5.
rewrite beta 7 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else x6) 5 In_5_7.
rewrite If_0 set (5 = 0) x0 (if 5 = 1 then x1 else if 5 = 2 then x2 else if 5 = 3 then x3 else if 5 = 4 then x4 else if 5 = 5 then x5 else x6) neq_5_0.
rewrite If_0 set (5 = 1) x1 (if 5 = 2 then x2 else if 5 = 3 then x3 else if 5 = 4 then x4 else if 5 = 5 then x5 else x6) neq_5_1.
rewrite If_0 set (5 = 2) x2 (if 5 = 3 then x3 else if 5 = 4 then x4 else if 5 = 5 then x5 else x6) neq_5_2.
rewrite If_0 set (5 = 3) x3 (if 5 = 4 then x4 else if 5 = 5 then x5 else x6) neq_5_3.
rewrite If_0 set (5 = 4) x4 (if 5 = 5 then x5 else x6) neq_5_4.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_7_6_eq: (x0,x1,x2,x3,x4,x5,x6) 6 = x6.
rewrite beta 7 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else x6) 6 In_6_7.
rewrite If_0 set (6 = 0) x0 (if 6 = 1 then x1 else if 6 = 2 then x2 else if 6 = 3 then x3 else if 6 = 4 then x4 else if 6 = 5 then x5 else x6) neq_6_0.
rewrite If_0 set (6 = 1) x1 (if 6 = 2 then x2 else if 6 = 3 then x3 else if 6 = 4 then x4 else if 6 = 5 then x5 else x6) neq_6_1.
rewrite If_0 set (6 = 2) x2 (if 6 = 3 then x3 else if 6 = 4 then x4 else if 6 = 5 then x5 else x6) neq_6_2.
rewrite If_0 set (6 = 3) x3 (if 6 = 4 then x4 else if 6 = 5 then x5 else x6) neq_6_3.
rewrite If_0 set (6 = 4) x4 (if 6 = 5 then x5 else x6) neq_6_4.
apply If_0 set. apply neq_6_5.
Qed.

Variable x7: set.
Theorem tuple_8_0_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 0 = x0.
rewrite beta 8 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else x7) 0 In_0_8.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_8_1_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 1 = x1.
rewrite beta 8 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else x7) 1 In_1_8.
rewrite If_0 set (1 = 0) x0 (if 1 = 1 then x1 else if 1 = 2 then x2 else if 1 = 3 then x3 else if 1 = 4 then x4 else if 1 = 5 then x5 else if 1 = 6 then x6 else x7) neq_1_0.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_8_2_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 2 = x2.
rewrite beta 8 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else x7) 2 In_2_8.
rewrite If_0 set (2 = 0) x0 (if 2 = 1 then x1 else if 2 = 2 then x2 else if 2 = 3 then x3 else if 2 = 4 then x4 else if 2 = 5 then x5 else if 2 = 6 then x6 else x7) neq_2_0.
rewrite If_0 set (2 = 1) x1 (if 2 = 2 then x2 else if 2 = 3 then x3 else if 2 = 4 then x4 else if 2 = 5 then x5 else if 2 = 6 then x6 else x7) neq_2_1.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_8_3_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 3 = x3.
rewrite beta 8 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else x7) 3 In_3_8.
rewrite If_0 set (3 = 0) x0 (if 3 = 1 then x1 else if 3 = 2 then x2 else if 3 = 3 then x3 else if 3 = 4 then x4 else if 3 = 5 then x5 else if 3 = 6 then x6 else x7) neq_3_0.
rewrite If_0 set (3 = 1) x1 (if 3 = 2 then x2 else if 3 = 3 then x3 else if 3 = 4 then x4 else if 3 = 5 then x5 else if 3 = 6 then x6 else x7) neq_3_1.
rewrite If_0 set (3 = 2) x2 (if 3 = 3 then x3 else if 3 = 4 then x4 else if 3 = 5 then x5 else if 3 = 6 then x6 else x7) neq_3_2.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_8_4_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 4 = x4.
rewrite beta 8 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else x7) 4 In_4_8.
rewrite If_0 set (4 = 0) x0 (if 4 = 1 then x1 else if 4 = 2 then x2 else if 4 = 3 then x3 else if 4 = 4 then x4 else if 4 = 5 then x5 else if 4 = 6 then x6 else x7) neq_4_0.
rewrite If_0 set (4 = 1) x1 (if 4 = 2 then x2 else if 4 = 3 then x3 else if 4 = 4 then x4 else if 4 = 5 then x5 else if 4 = 6 then x6 else x7) neq_4_1.
rewrite If_0 set (4 = 2) x2 (if 4 = 3 then x3 else if 4 = 4 then x4 else if 4 = 5 then x5 else if 4 = 6 then x6 else x7) neq_4_2.
rewrite If_0 set (4 = 3) x3 (if 4 = 4 then x4 else if 4 = 5 then x5 else if 4 = 6 then x6 else x7) neq_4_3.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_8_5_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 5 = x5.
rewrite beta 8 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else x7) 5 In_5_8.
rewrite If_0 set (5 = 0) x0 (if 5 = 1 then x1 else if 5 = 2 then x2 else if 5 = 3 then x3 else if 5 = 4 then x4 else if 5 = 5 then x5 else if 5 = 6 then x6 else x7) neq_5_0.
rewrite If_0 set (5 = 1) x1 (if 5 = 2 then x2 else if 5 = 3 then x3 else if 5 = 4 then x4 else if 5 = 5 then x5 else if 5 = 6 then x6 else x7) neq_5_1.
rewrite If_0 set (5 = 2) x2 (if 5 = 3 then x3 else if 5 = 4 then x4 else if 5 = 5 then x5 else if 5 = 6 then x6 else x7) neq_5_2.
rewrite If_0 set (5 = 3) x3 (if 5 = 4 then x4 else if 5 = 5 then x5 else if 5 = 6 then x6 else x7) neq_5_3.
rewrite If_0 set (5 = 4) x4 (if 5 = 5 then x5 else if 5 = 6 then x6 else x7) neq_5_4.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_8_6_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 6 = x6.
rewrite beta 8 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else x7) 6 In_6_8.
rewrite If_0 set (6 = 0) x0 (if 6 = 1 then x1 else if 6 = 2 then x2 else if 6 = 3 then x3 else if 6 = 4 then x4 else if 6 = 5 then x5 else if 6 = 6 then x6 else x7) neq_6_0.
rewrite If_0 set (6 = 1) x1 (if 6 = 2 then x2 else if 6 = 3 then x3 else if 6 = 4 then x4 else if 6 = 5 then x5 else if 6 = 6 then x6 else x7) neq_6_1.
rewrite If_0 set (6 = 2) x2 (if 6 = 3 then x3 else if 6 = 4 then x4 else if 6 = 5 then x5 else if 6 = 6 then x6 else x7) neq_6_2.
rewrite If_0 set (6 = 3) x3 (if 6 = 4 then x4 else if 6 = 5 then x5 else if 6 = 6 then x6 else x7) neq_6_3.
rewrite If_0 set (6 = 4) x4 (if 6 = 5 then x5 else if 6 = 6 then x6 else x7) neq_6_4.
rewrite If_0 set (6 = 5) x5 (if 6 = 6 then x6 else x7) neq_6_5.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_8_7_eq: (x0,x1,x2,x3,x4,x5,x6,x7) 7 = x7.
rewrite beta 8 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else x7) 7 In_7_8.
rewrite If_0 set (7 = 0) x0 (if 7 = 1 then x1 else if 7 = 2 then x2 else if 7 = 3 then x3 else if 7 = 4 then x4 else if 7 = 5 then x5 else if 7 = 6 then x6 else x7) neq_7_0.
rewrite If_0 set (7 = 1) x1 (if 7 = 2 then x2 else if 7 = 3 then x3 else if 7 = 4 then x4 else if 7 = 5 then x5 else if 7 = 6 then x6 else x7) neq_7_1.
rewrite If_0 set (7 = 2) x2 (if 7 = 3 then x3 else if 7 = 4 then x4 else if 7 = 5 then x5 else if 7 = 6 then x6 else x7) neq_7_2.
rewrite If_0 set (7 = 3) x3 (if 7 = 4 then x4 else if 7 = 5 then x5 else if 7 = 6 then x6 else x7) neq_7_3.
rewrite If_0 set (7 = 4) x4 (if 7 = 5 then x5 else if 7 = 6 then x6 else x7) neq_7_4.
rewrite If_0 set (7 = 5) x5 (if 7 = 6 then x6 else x7) neq_7_5.
apply If_0 set. apply neq_7_6.
Qed.

Variable x8: set.
Theorem tuple_9_0_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 0 = x0.
rewrite beta 9 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else if i = 7 then x7 else x8) 0 In_0_9.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_9_1_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 1 = x1.
rewrite beta 9 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else if i = 7 then x7 else x8) 1 In_1_9.
rewrite If_0 set (1 = 0) x0 (if 1 = 1 then x1 else if 1 = 2 then x2 else if 1 = 3 then x3 else if 1 = 4 then x4 else if 1 = 5 then x5 else if 1 = 6 then x6 else if 1 = 7 then x7 else x8) neq_1_0.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_9_2_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 2 = x2.
rewrite beta 9 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else if i = 7 then x7 else x8) 2 In_2_9.
rewrite If_0 set (2 = 0) x0 (if 2 = 1 then x1 else if 2 = 2 then x2 else if 2 = 3 then x3 else if 2 = 4 then x4 else if 2 = 5 then x5 else if 2 = 6 then x6 else if 2 = 7 then x7 else x8) neq_2_0.
rewrite If_0 set (2 = 1) x1 (if 2 = 2 then x2 else if 2 = 3 then x3 else if 2 = 4 then x4 else if 2 = 5 then x5 else if 2 = 6 then x6 else if 2 = 7 then x7 else x8) neq_2_1.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_9_3_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 3 = x3.
rewrite beta 9 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else if i = 7 then x7 else x8) 3 In_3_9.
rewrite If_0 set (3 = 0) x0 (if 3 = 1 then x1 else if 3 = 2 then x2 else if 3 = 3 then x3 else if 3 = 4 then x4 else if 3 = 5 then x5 else if 3 = 6 then x6 else if 3 = 7 then x7 else x8) neq_3_0.
rewrite If_0 set (3 = 1) x1 (if 3 = 2 then x2 else if 3 = 3 then x3 else if 3 = 4 then x4 else if 3 = 5 then x5 else if 3 = 6 then x6 else if 3 = 7 then x7 else x8) neq_3_1.
rewrite If_0 set (3 = 2) x2 (if 3 = 3 then x3 else if 3 = 4 then x4 else if 3 = 5 then x5 else if 3 = 6 then x6 else if 3 = 7 then x7 else x8) neq_3_2.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_9_4_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 4 = x4.
rewrite beta 9 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else if i = 7 then x7 else x8) 4 In_4_9.
rewrite If_0 set (4 = 0) x0 (if 4 = 1 then x1 else if 4 = 2 then x2 else if 4 = 3 then x3 else if 4 = 4 then x4 else if 4 = 5 then x5 else if 4 = 6 then x6 else if 4 = 7 then x7 else x8) neq_4_0.
rewrite If_0 set (4 = 1) x1 (if 4 = 2 then x2 else if 4 = 3 then x3 else if 4 = 4 then x4 else if 4 = 5 then x5 else if 4 = 6 then x6 else if 4 = 7 then x7 else x8) neq_4_1.
rewrite If_0 set (4 = 2) x2 (if 4 = 3 then x3 else if 4 = 4 then x4 else if 4 = 5 then x5 else if 4 = 6 then x6 else if 4 = 7 then x7 else x8) neq_4_2.
rewrite If_0 set (4 = 3) x3 (if 4 = 4 then x4 else if 4 = 5 then x5 else if 4 = 6 then x6 else if 4 = 7 then x7 else x8) neq_4_3.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_9_5_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 5 = x5.
rewrite beta 9 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else if i = 7 then x7 else x8) 5 In_5_9.
rewrite If_0 set (5 = 0) x0 (if 5 = 1 then x1 else if 5 = 2 then x2 else if 5 = 3 then x3 else if 5 = 4 then x4 else if 5 = 5 then x5 else if 5 = 6 then x6 else if 5 = 7 then x7 else x8) neq_5_0.
rewrite If_0 set (5 = 1) x1 (if 5 = 2 then x2 else if 5 = 3 then x3 else if 5 = 4 then x4 else if 5 = 5 then x5 else if 5 = 6 then x6 else if 5 = 7 then x7 else x8) neq_5_1.
rewrite If_0 set (5 = 2) x2 (if 5 = 3 then x3 else if 5 = 4 then x4 else if 5 = 5 then x5 else if 5 = 6 then x6 else if 5 = 7 then x7 else x8) neq_5_2.
rewrite If_0 set (5 = 3) x3 (if 5 = 4 then x4 else if 5 = 5 then x5 else if 5 = 6 then x6 else if 5 = 7 then x7 else x8) neq_5_3.
rewrite If_0 set (5 = 4) x4 (if 5 = 5 then x5 else if 5 = 6 then x6 else if 5 = 7 then x7 else x8) neq_5_4.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_9_6_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 6 = x6.
rewrite beta 9 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else if i = 7 then x7 else x8) 6 In_6_9.
rewrite If_0 set (6 = 0) x0 (if 6 = 1 then x1 else if 6 = 2 then x2 else if 6 = 3 then x3 else if 6 = 4 then x4 else if 6 = 5 then x5 else if 6 = 6 then x6 else if 6 = 7 then x7 else x8) neq_6_0.
rewrite If_0 set (6 = 1) x1 (if 6 = 2 then x2 else if 6 = 3 then x3 else if 6 = 4 then x4 else if 6 = 5 then x5 else if 6 = 6 then x6 else if 6 = 7 then x7 else x8) neq_6_1.
rewrite If_0 set (6 = 2) x2 (if 6 = 3 then x3 else if 6 = 4 then x4 else if 6 = 5 then x5 else if 6 = 6 then x6 else if 6 = 7 then x7 else x8) neq_6_2.
rewrite If_0 set (6 = 3) x3 (if 6 = 4 then x4 else if 6 = 5 then x5 else if 6 = 6 then x6 else if 6 = 7 then x7 else x8) neq_6_3.
rewrite If_0 set (6 = 4) x4 (if 6 = 5 then x5 else if 6 = 6 then x6 else if 6 = 7 then x7 else x8) neq_6_4.
rewrite If_0 set (6 = 5) x5 (if 6 = 6 then x6 else if 6 = 7 then x7 else x8) neq_6_5.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_9_7_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 7 = x7.
rewrite beta 9 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else if i = 7 then x7 else x8) 7 In_7_9.
rewrite If_0 set (7 = 0) x0 (if 7 = 1 then x1 else if 7 = 2 then x2 else if 7 = 3 then x3 else if 7 = 4 then x4 else if 7 = 5 then x5 else if 7 = 6 then x6 else if 7 = 7 then x7 else x8) neq_7_0.
rewrite If_0 set (7 = 1) x1 (if 7 = 2 then x2 else if 7 = 3 then x3 else if 7 = 4 then x4 else if 7 = 5 then x5 else if 7 = 6 then x6 else if 7 = 7 then x7 else x8) neq_7_1.
rewrite If_0 set (7 = 2) x2 (if 7 = 3 then x3 else if 7 = 4 then x4 else if 7 = 5 then x5 else if 7 = 6 then x6 else if 7 = 7 then x7 else x8) neq_7_2.
rewrite If_0 set (7 = 3) x3 (if 7 = 4 then x4 else if 7 = 5 then x5 else if 7 = 6 then x6 else if 7 = 7 then x7 else x8) neq_7_3.
rewrite If_0 set (7 = 4) x4 (if 7 = 5 then x5 else if 7 = 6 then x6 else if 7 = 7 then x7 else x8) neq_7_4.
rewrite If_0 set (7 = 5) x5 (if 7 = 6 then x6 else if 7 = 7 then x7 else x8) neq_7_5.
rewrite If_0 set (7 = 6) x6 (if 7 = 7 then x7 else x8) neq_7_6.
apply If_1 set. apply eqI set.
Qed.

Theorem tuple_9_8_eq: (x0,x1,x2,x3,x4,x5,x6,x7,x8) 8 = x8.
rewrite beta 9 (fun i => if i = 0 then x0 else if i = 1 then x1 else if i = 2 then x2 else if i = 3 then x3 else if i = 4 then x4 else if i = 5 then x5 else if i = 6 then x6 else if i = 7 then x7 else x8) 8 In_8_9.
rewrite If_0 set (8 = 0) x0 (if 8 = 1 then x1 else if 8 = 2 then x2 else if 8 = 3 then x3 else if 8 = 4 then x4 else if 8 = 5 then x5 else if 8 = 6 then x6 else if 8 = 7 then x7 else x8) neq_8_0.
rewrite If_0 set (8 = 1) x1 (if 8 = 2 then x2 else if 8 = 3 then x3 else if 8 = 4 then x4 else if 8 = 5 then x5 else if 8 = 6 then x6 else if 8 = 7 then x7 else x8) neq_8_1.
rewrite If_0 set (8 = 2) x2 (if 8 = 3 then x3 else if 8 = 4 then x4 else if 8 = 5 then x5 else if 8 = 6 then x6 else if 8 = 7 then x7 else x8) neq_8_2.
rewrite If_0 set (8 = 3) x3 (if 8 = 4 then x4 else if 8 = 5 then x5 else if 8 = 6 then x6 else if 8 = 7 then x7 else x8) neq_8_3.
rewrite If_0 set (8 = 4) x4 (if 8 = 5 then x5 else if 8 = 6 then x6 else if 8 = 7 then x7 else x8) neq_8_4.
rewrite If_0 set (8 = 5) x5 (if 8 = 6 then x6 else if 8 = 7 then x7 else x8) neq_8_5.
rewrite If_0 set (8 = 6) x6 (if 8 = 7 then x7 else x8) neq_8_6.
apply If_0 set. apply neq_8_7.
Qed.

End Tuples.

Axiom pair_Sigma : forall X : set , forall Y : set -> set , forall x :e X , forall y :e Y x , pair x y :e Sigma_ x :e X , Y x.
Axiom tuple_pair : forall x y : set , pair x y = (x,y).

Theorem pair_tuple_fun : pair = (fun x y => (x,y)).
apply func_ext set (set -> set). let x.
apply func_ext set set. let y.
prove pair x y = (x,y).
apply tuple_pair.
Qed.

Theorem tuple_2_inj : forall x y w z:set, (x,y) = (w,z) -> x = w /\ y = z.
prove forall x y w z:set, (fun x y:set => (x,y)) x y = (fun w z:set => (w,z)) w z -> x = w /\ y = z.
rewrite <- pair_tuple_fun.
rewrite <- pair_tuple_fun.
exact pair_inj.
Qed.

Theorem tuple_2_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, (x,y) :e Sigma_ x :e X, Y x.
prove forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, ((fun x y:set => (x,y)) x y) :e Sigma_ x :e X, Y x.
rewrite <- pair_tuple_fun.
exact pair_Sigma.
Qed.

Theorem tuple_2_setprod : forall X:set, forall Y:set, forall x :e X, forall y :e Y, (x,y) :e X :*: Y.
exact fun X Y x Hx y Hy => tuple_2_Sigma X (fun _ => Y) x Hx y Hy.
Qed.

Theorem lamI2 : forall X, forall F:set->set, forall x :e X, forall y :e F x, (x,y) :e fun x :e X => F x.
prove (forall X, forall F:set->set, forall x :e X, forall y :e F x, ((fun x y:set => (x,y)) x y) :e fun x :e X => F x).
rewrite <- pair_tuple_fun.
exact lamI.
Qed.

Theorem lamE2 : forall X, forall F : set -> set , forall z : set , z :e (fun x :e X => F x) -> exists x :e X, exists y :e F x, z = (x,y).
prove forall X, forall F : set -> set , forall z : set , z :e (fun x :e X => F x) -> exists x :e X , exists y :e F x , z = (fun x y:set => (x,y)) x y.
rewrite <- pair_tuple_fun.
exact lamE.
Qed.

Theorem apI2 : forall f x y, (x,y) :e f -> y :e f x.
prove forall f x y, ((fun x y:set => (x,y)) x y) :e f -> y :e f x.
rewrite <- pair_tuple_fun.
exact apI.
Qed.

Theorem apE2 : forall f x y, y :e f x -> (x,y) :e f.
prove forall f x y, y :e f x -> ((fun x y:set => (x,y)) x y) :e f.
rewrite <- pair_tuple_fun.
exact apE.
Qed.

Lemma ap_const_0 : forall x, 0 x = 0.
let x. apply Empty_Subq_eq.
prove 0 x c= 0.
let y. assume Hy: y :e 0 x.
claim L1: (x,y) :e 0.
{ exact apE2 0 x y Hy. }
apply EmptyE (x,y) L1.
Qed.

Theorem lam_ext_sub: forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> (fun x :e X => F x) c= (fun x :e X => G x).
let X F G.
assume HFG: forall x :e X, F x = G x.
let z. assume Hz: z :e (fun x :e X => F x).
claim L1: exists x :e X, exists y :e F x, z = (x,y).
{ exact lamE2 X F z Hz. }
apply L1.
let x. assume H1. apply H1.
assume Hx: x :e X.
assume H2. apply H2.
let y. assume H3. apply H3.
assume Hy: y :e F x.
assume Hz: z = (x,y).
prove z :e (fun x :e X => G x).
rewrite Hz.
prove (x,y) :e (fun x :e X => G x).
apply lamI2.
- exact Hx.
- rewrite <- HFG x Hx. exact Hy.
Qed.

Theorem lam_ext: forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> (fun x :e X => F x) = (fun x :e X => G x).
let X F G. assume H1. apply set_ext.
- exact lam_ext_sub X F G H1.
- apply lam_ext_sub X G F. let x. assume Hx. apply eq_sym set. exact H1 x Hx.
Qed.

Theorem lam_eta: forall X, forall F:set -> set, (fun x :e X => (fun x :e X => F x) x) = (fun x :e X => F x).
let X F.
apply lam_ext.
let x. assume Hx.
exact beta X F x Hx.
Qed.

Theorem tuple_2_eta : forall x y, (fun i :e 2 => (x,y) i) = (x,y).
let x y. exact lam_eta 2 (fun i => if i = 0 then x else y).
Qed.

Lemma tuple_3_eta : forall x y z, (fun i :e 3 => (x,y,z) i) = (x,y,z).
let x y z. exact lam_eta 3 (fun i => if i = 0 then x else if i = 1 then y else z).
Qed.

Lemma tuple_4_eta : forall x y z w, (fun i :e 4 => (x,y,z,w) i) = (x,y,z,w).
let x y z w. exact lam_eta 4 (fun i => if i = 0 then x else if i = 1 then y else if i = 2 then z else w).
Qed.

Definition Sep2 : set -> (set -> set) -> (set -> set -> prop) -> set
 := fun X Y R => {u :e Sigma_ x :e X, Y x | R (u 0) (u 1)}.

Theorem Sep2I: forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall x :e X, forall y :e Y x, R x y -> (x,y) :e Sep2 X Y R.
let X Y R x. assume Hx. let y. assume Hy HR.
prove (x,y) :e {u :e Sigma_ x :e X, Y x | R (u 0) (u 1)}.
apply SepI.
- prove (x,y) :e Sigma_ x :e X, Y x. apply lamI2.
  + exact Hx.
  + exact Hy.
- prove R ((x,y) 0) ((x,y) 1).
  rewrite tuple_2_0_eq.
  rewrite tuple_2_1_eq.
  exact HR.
Qed.

Theorem Sep2E: forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall u :e Sep2 X Y R, exists x :e X, exists y :e Y x, u = (x,y) /\ R x y.
let X Y R u. assume Hu.
apply SepE (Sigma_ x :e X, Y x) (fun u => R (u 0) (u 1)) u Hu.
assume H1: u :e Sigma_ x :e X, Y x.
assume H2: R (u 0) (u 1).
apply lamE2 X Y u H1.
let x. assume H3. apply H3.
assume Hx: x :e X. assume H4. apply H4.
let y. assume H5. apply H5.
assume Hy: y :e Y x.
assume H6: u = (x,y).
witness x. apply andI.
- exact Hx.
- witness y. apply andI.
  + exact Hy.
  + apply andI.
    * exact H6.
    * claim L1: R ((x,y) 0) ((x,y) 1).
      { rewrite <- H6. exact H2. }
      claim L2: R ((x,y) 0) ((x,y) 1) -> R x y.
      { rewrite tuple_2_0_eq. rewrite tuple_2_1_eq. exact (fun H => H). }
      exact L2 L1.
Qed.

Theorem Sep2E': forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall x y, (x,y) :e Sep2 X Y R -> x :e X /\ y :e Y x /\ R x y.
let X Y R x y. assume Hxy.
claim L1: exists x' :e X, exists y' :e Y x', (x,y) = (x',y') /\ R x' y'.
{ exact Sep2E X Y R (x,y) Hxy. }
apply L1.
let x'. assume H1. apply H1.
assume Hx' H2. apply H2.
let y'. assume H3. apply H3.
assume Hy' H4. apply H4.
assume H5: (x,y) = (x',y').
assume H6: R x' y'.
apply tuple_2_inj x y x' y' H5.
assume H7: x = x'.
assume H8: y = y'.
prove x :e X /\ y :e Y x /\ R x y.
rewrite H7. rewrite H8.
prove x' :e X /\ y' :e Y x' /\ R x' y'.
apply and3I.
- exact Hx'.
- exact Hy'.
- exact H6.
Qed.

Theorem Sep2E'1: forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall x y, (x,y) :e Sep2 X Y R -> x :e X.
let X Y R x y. assume Hxy.
claim L1: x :e X /\ y :e Y x /\ R x y.
{ exact Sep2E' X Y R x y Hxy. }
apply L1. assume H1 _. apply H1. assume H2 _. exact H2.
Qed.

Theorem Sep2E'2: forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall x y, (x,y) :e Sep2 X Y R -> y :e Y x.
let X Y R x y. assume Hxy.
claim L1: x :e X /\ y :e Y x /\ R x y.
{ exact Sep2E' X Y R x y Hxy. }
apply L1. assume H1 _. apply H1. assume _ H2. exact H2.
Qed.

Theorem Sep2E'3: forall X, forall Y:set -> set, forall R:set -> set -> prop,
   forall x y, (x,y) :e Sep2 X Y R -> R x y.
let X Y R x y. assume Hxy.
claim L1: x :e X /\ y :e Y x /\ R x y.
{ exact Sep2E' X Y R x y Hxy. }
apply L1. assume _ H1. exact H1.
Qed.

Definition set_of_pairs : set -> prop := fun X => forall x :e X, exists y z, x = (y,z).

Theorem set_of_pairs_ext : forall X Y,
     set_of_pairs X -> set_of_pairs Y
  -> (forall v w, (v,w) :e X <-> (v,w) :e Y)
  -> X = Y.
let X Y. assume HX HY HE. apply set_ext.
- let x. assume Hx.
  prove x :e Y.
  apply HX x Hx. let v. assume H1. apply H1. let w. assume H2: x = (v,w).
  rewrite H2.
  prove (v,w) :e Y.
  apply HE v w. assume HE1 HE2. apply HE1.
  prove (v,w) :e X.
  exact H2 (fun x => x :e X) Hx.
- let x. assume Hx.
  prove x :e X.
  apply HY x Hx. let v. assume H1. apply H1. let w. assume H2: x = (v,w).
  rewrite H2.
  prove (v,w) :e X.
  apply HE v w. assume HE1 HE2. apply HE2.
  prove (v,w) :e Y.
  exact H2 (fun x => x :e Y) Hx.
Qed.

Theorem Sep2_set_of_pairs : forall X, forall Y:set -> set, forall R:set -> set -> prop,
   set_of_pairs (Sep2 X Y R).
let X Y R u. assume Hu: u :e Sep2 X Y R.
prove exists x y, u = (x,y).
apply Sep2E X Y R u Hu.
let x. assume H1. apply H1.
assume _ H2. apply H2.
let y. assume H3. apply H3.
assume _ H4. apply H4.
assume H5: u = (x,y).
assume _.
witness x.
witness y.
exact H5.
Qed.

Theorem Sep2_ext : forall X, forall Y:set -> set, forall R R':set -> set -> prop,
     (forall x :e X, forall y :e Y x, R x y <-> R' x y)
  -> Sep2 X Y R = Sep2 X Y R'.
let X Y R R'.
assume HE.
apply set_of_pairs_ext.
- apply Sep2_set_of_pairs.
- apply Sep2_set_of_pairs.
- let x y. apply iffI.
  + assume Hxy: (x,y) :e Sep2 X Y R.
    apply Sep2E' X Y R x y Hxy.
    assume H1 HR. apply H1.
    assume Hx: x :e X.
    assume Hy: y :e Y x.
    apply Sep2I.
    * exact Hx.
    * exact Hy.
    * apply HE x Hx y Hy. assume HE1 HE2. apply HE1. exact HR.
  + assume Hxy: (x,y) :e Sep2 X Y R'.
    apply Sep2E' X Y R' x y Hxy.
    assume H1 HR. apply H1.
    assume Hx: x :e X.
    assume Hy: y :e Y x.
    apply Sep2I.
    * exact Hx.
    * exact Hy.
    * apply HE x Hx y Hy. assume HE1 HE2. apply HE2. exact HR.
Qed.

Definition lam2 : set -> (set -> set) -> (set -> set -> set) -> set
 := fun X Y F => fun x :e X => fun y :e Y x => F x y.

Lemma beta2 : forall X, forall Y:set -> set, forall F:set->set->set, forall x :e X, forall y :e Y x, lam2 X Y F x y = F x y.
let X Y F x. assume Hx: x :e X. let y. assume Hy: y :e Y x.
prove (fun x :e X => fun y :e Y x => F x y) x y = F x y.
rewrite beta X (fun x => (fun y :e Y x => F x y)) x.
- prove (fun y :e Y x => F x y) y = F x y.
  apply beta. exact Hy.
- exact Hx.
Qed.

Theorem lam2_ext: forall X, forall Y:set -> set, forall F G:set -> set -> set,
     (forall x :e X, forall y :e Y x, F x y = G x y)
  -> lam2 X Y F = lam2 X Y G.
let X Y F G. assume H1.
prove (fun x :e X => fun y :e Y x => F x y) = (fun x :e X => fun y :e Y x => G x y).
apply lam_ext.
let x. assume Hx.
prove (fun y :e Y x => F x y) = (fun y :e Y x => G x y).
apply lam_ext.
let y. assume Hy.
exact H1 x Hx y Hy.
Qed.

Theorem PigeonHole_nat : forall n, nat_p n -> forall f:set -> set, (forall i :e ordsucc n, f i :e n) -> ~(forall i j :e ordsucc n, f i = f j -> i = j).
apply nat_ind (fun n => forall f:set -> set, (forall i :e ordsucc n, f i :e n) -> ~(forall i j :e ordsucc n, f i = f j -> i = j)).
- prove forall f:set -> set, (forall i :e 1, f i :e 0) -> ~(forall i j :e 1, f i = f j -> i = j).
  let f. assume H1. apply EmptyE (f 0) (H1 0 In_0_1).
- let n. assume Hn: nat_p n.
  assume IH: forall f:set -> set, (forall i :e ordsucc n, f i :e n) -> ~(forall i j :e ordsucc n, f i = f j -> i = j).
  let f.
  assume H1: forall i :e ordsucc (ordsucc n), f i :e ordsucc n.
  assume H2: forall i j :e ordsucc (ordsucc n), f i = f j -> i = j.
  apply classic (exists i :e ordsucc (ordsucc n), f i = n).
  + assume H3. apply H3. let k. assume Hk. apply Hk.
    assume Hk1: k :e ordsucc (ordsucc n).
    assume Hk2: f k = n.
    set f' := fun i:set => if k c= i then f (ordsucc i) else f i.
    apply IH f'.
    * { prove forall i :e ordsucc n, f' i :e n.
        let i. assume Hi: i :e ordsucc n.
        apply classic (k c= i).
	- assume H4: k c= i.
          prove (if k c= i then f (ordsucc i) else f i) :e n.
	  rewrite If_1 set (k c= i) (f (ordsucc i)) (f i) H4.
	  prove f (ordsucc i) :e n.
	  claim L1: ordsucc i :e ordsucc (ordsucc n).
          { apply nat_ordsucc_in_ordsucc.
	    - apply nat_ordsucc. exact Hn.
	    - exact Hi.
	  }
	  apply ordsuccE n (f (ordsucc i)) (H1 (ordsucc i) L1).
	  + assume H5: f (ordsucc i) :e n. exact H5.
	  + assume H5: f (ordsucc i) = n.
	    prove False.
	    apply In_irref i.
	    prove i :e i.
	    claim L2: k = ordsucc i.
	    { apply H2.
	      - exact Hk1.
	      - exact L1.
	      - rewrite H5. exact Hk2.
	    }
	    claim L3: i :e k.
	    { rewrite L2. apply ordsuccI2. }
	    exact H4 i L3.
	- assume H4: ~(k c= i).
          prove (if k c= i then f (ordsucc i) else f i) :e n.
	  rewrite If_0 set (k c= i) (f (ordsucc i)) (f i) H4.
	  prove f i :e n.
	  apply ordsuccE n (f i) (H1 i (ordsuccI1 (ordsucc n) i Hi)).
	  + assume H5: f i :e n. exact H5.
	  + assume H5: f i = n.
	    prove False.
	    apply H4.
	    prove k c= i.
	    claim L2: k = i.
	    { apply H2.
	      - exact Hk1.
	      - exact ordsuccI1 (ordsucc n) i Hi.
	      - rewrite H5. exact Hk2.
	    }
	    rewrite <- L2.
	    exact (fun x Hx => Hx).
      }
    * { prove forall i j :e ordsucc n, f' i = f' j -> i = j.
        let i. assume Hi. let j. assume Hj.
	prove (if k c= i then f (ordsucc i) else f i) = (if k c= j then f (ordsucc j) else f j) -> i = j.
	claim Li1: i :e ordsucc (ordsucc n).
	{ apply ordsuccI1. exact Hi. }
	claim Li2: ordsucc i :e ordsucc (ordsucc n).
	{ apply nat_ordsucc_in_ordsucc.
	  - apply nat_ordsucc. exact Hn.
	  - exact Hi.
        }
	claim Lj1: j :e ordsucc (ordsucc n).
	{ apply ordsuccI1. exact Hj. }
	claim Lj2: ordsucc j :e ordsucc (ordsucc n).
	{ apply nat_ordsucc_in_ordsucc.
	  - apply nat_ordsucc. exact Hn.
	  - exact Hj.
        }
	apply classic (k c= i).
	- assume H4: k c= i.
	  rewrite If_1 set (k c= i) (f (ordsucc i)) (f i) H4.
	  apply classic (k c= j).
	  + assume H5: k c= j.
	    rewrite If_1 set (k c= j) (f (ordsucc j)) (f j) H5.
	    prove f (ordsucc i) = f (ordsucc j) -> i = j.
	    assume H6.
	    apply ordsucc_inj.
	    prove ordsucc i = ordsucc j.
	    exact H2 (ordsucc i) Li2 (ordsucc j) Lj2 H6.
	  + assume H5: ~(k c= j).
	    rewrite If_0 set (k c= j) (f (ordsucc j)) (f j) H5.
	    prove f (ordsucc i) = f j -> i = j.
	    assume H6.
	    prove False.
	    claim L3: ordsucc i = j.
	    { apply H2.
	      - exact Li2.
	      - exact Lj1.
	      - exact H6.
	    }
	    apply H5.
	    rewrite <- L3.
	    let x. assume Hx: x :e k.
	    apply ordsuccI1. apply H4. exact Hx.
	- assume H4: ~(k c= i).
	  rewrite If_0 set (k c= i) (f (ordsucc i)) (f i) H4.
	  apply classic (k c= j).
	  + assume H5: k c= j.
	    rewrite If_1 set (k c= j) (f (ordsucc j)) (f j) H5.
	    prove f i = f (ordsucc j) -> i = j.
	    assume H6.
	    prove False.
	    claim L3: i = ordsucc j.
	    { apply H2.
	      - exact Li1.
	      - exact Lj2.
	      - exact H6.
	    }
	    apply H4.
	    rewrite L3.
	    let x. assume Hx: x :e k.
	    apply ordsuccI1. apply H5. exact Hx.
	  + assume H5: ~(k c= j).
	    rewrite If_0 set (k c= j) (f (ordsucc j)) (f j) H5.
	    prove f i = f j -> i = j.
	    apply H2.
	    * exact Li1.
	    * exact Lj1.
      }
  + assume H3: ~(exists i :e ordsucc (ordsucc n), f i = n).
    apply IH f.
    * { prove forall i :e ordsucc n, f i :e n.
        let i. assume Hi: i :e ordsucc n.
	apply ordsuccE n (f i) (H1 i (ordsuccI1 (ordsucc n) i Hi)).
	- assume Hfi: f i :e n. exact Hfi.
	- assume Hfi: f i = n. apply H3. witness i. apply andI.
	  + apply ordsuccI1. exact Hi.
	  + exact Hfi.
      }
    * { prove forall i j :e ordsucc n, f i = f j -> i = j.
        let i. assume Hi. let j. assume Hj.
	apply H2.
	- apply ordsuccI1. exact Hi.
	- apply ordsuccI1. exact Hj.
      }
Qed.

Theorem PigeonHole_nat_bij : forall n, nat_p n -> forall f:set -> set, (forall i :e n, f i :e n) -> (forall i j :e n, f i = f j -> i = j) -> bij n n f.
let n. assume Hn. let f. assume Hf1 Hf2.
prove (forall i :e n, f i :e n)
   /\ (forall i j :e n, f i = f j -> i = j)
   /\ (forall j :e n, exists i :e n, f i = j).
apply and3I.
- exact Hf1.
- exact Hf2.
- let j. assume Hj: j :e n. apply NNPP. assume H1: ~exists i :e n, f i = j.
  set f' := fun i:set => if i = n then j else f i.
  apply PigeonHole_nat n Hn f'.
  + prove forall i :e ordsucc n, f' i :e n.
    let i. assume Hi.
    prove (if i = n then j else f i) :e n.
    apply classic (i = n).
    * assume H1: i = n.
      rewrite If_1 set (i = n) j (f i) H1.
      prove j :e n.
      exact Hj.
    * { assume H1: i <> n.
        rewrite If_0 set (i = n) j (f i) H1.
        prove f i :e n.
        apply Hf1.
        apply ordsuccE n i Hi.
	- assume H2: i :e n. exact H2.
	- assume H2: i = n. apply H1 H2.
      }
  + prove forall i k :e ordsucc n, f' i = f' k -> i = k.
    let i. assume Hi. let k. assume Hk.
    claim Li: i <> n -> i :e n.
    { assume Hin: i <> n.
      apply ordsuccE n i Hi.
      - assume H2. exact H2.
      - assume H2. apply Hin H2.
    }
    claim Lk: k <> n -> k :e n.
    { assume Hkn: k <> n.
      apply ordsuccE n k Hk.
      - assume H2. exact H2.
      - assume H2. apply Hkn H2.
    }
    prove (if i = n then j else f i) = (if k = n then j else f k) -> i = k.
    apply classic (i = n).
    * { assume H2: i = n.
        apply classic (k = n).
	- assume H3: k = n.
	  assume _. rewrite H3. exact H2.
	- assume H3: k <> n.
	  rewrite If_1 set (i = n) j (f i) H2.
	  rewrite If_0 set (k = n) j (f k) H3.
	  assume H4: j = f k.
	  apply H1. witness k.
	  apply andI.
	  + prove k :e n. exact Lk H3.
          + apply eq_sym set. exact H4.
      }
    * { assume H2: i <> n.
        apply classic (k = n).
	- assume H3: k = n.
	  rewrite If_0 set (i = n) j (f i) H2.
	  rewrite If_1 set (k = n) j (f k) H3.
	  assume H4: f i = j.
	  apply H1. witness i.
	  apply andI.
	  + prove i :e n. exact Li H2.
          + exact H4.
	- assume H3: k <> n.
	  rewrite If_0 set (i = n) j (f i) H2.
	  rewrite If_0 set (k = n) j (f k) H3.
	  prove f i = f k -> i = k.
	  apply Hf2.
	  + prove i :e n. exact Li H2.
	  + prove k :e n. exact Lk H3.
      }
Qed.

Theorem tuple_3_in_A_3 : forall x y z A, x :e A -> y :e A -> z :e A -> (x,y,z) :e A :^: 3.
let x y z A.
assume Hx Hy Hz.
rewrite <- tuple_3_eta x y z.
prove (fun i :e 3 => (x,y,z) i) :e Pi_ _ :e 3, A.
apply lam_Pi 3 (fun _ => A).
let i. assume Hi: i :e 3.
prove (x,y,z) i :e A.
apply cases_3 i Hi (fun i => (x,y,z) i :e A).
- prove (x,y,z) 0 :e A. rewrite tuple_3_0_eq. exact Hx.
- prove (x,y,z) 1 :e A. rewrite tuple_3_1_eq. exact Hy.
- prove (x,y,z) 2 :e A. rewrite tuple_3_2_eq. exact Hz.
Qed.

Theorem tuple_3_bij_3 : forall x y z, x :e 3 -> y :e 3 -> z :e 3 -> x <> y -> x <> z -> y <> z -> bij 3 3 (fun i => (x,y,z) i).
let x y z. assume Hx Hy Hz Hxy Hxz Hyz.
apply PigeonHole_nat_bij 3 (nat_ordsucc 2 nat_2) (fun i => (x,y,z) i).
- let u. assume Hu. apply cases_3 u Hu (fun u => (x,y,z) u :e 3).
  + prove (x,y,z) 0 :e 3. rewrite tuple_3_0_eq. exact Hx.
  + prove (x,y,z) 1 :e 3. rewrite tuple_3_1_eq. exact Hy.
  + prove (x,y,z) 2 :e 3. rewrite tuple_3_2_eq. exact Hz.
- let u. assume Hu. let v. assume Hv.
  apply cases_3 u Hu (fun u => (x,y,z) u = (x,y,z) v -> u = v).
  + apply cases_3 v Hv (fun v => (x,y,z) 0 = (x,y,z) v -> 0 = v).
    * assume _. apply eqI set.
    * rewrite tuple_3_0_eq.
      prove x = (x,y,z) 1 -> 0 = 1.
      rewrite tuple_3_1_eq. assume H1. apply Hxy H1.
    * rewrite tuple_3_0_eq.
      prove x = (x,y,z) 2 -> 0 = 2.
      rewrite tuple_3_2_eq. assume H1. apply Hxz H1.
  + apply cases_3 v Hv (fun v => (x,y,z) 1 = (x,y,z) v -> 1 = v).
    * rewrite tuple_3_1_eq.
      prove y = (x,y,z) 0 -> 1 = 0.
      rewrite tuple_3_0_eq. assume H1. apply Hxy.
      apply eq_sym set. exact H1.
    * assume _. apply eqI set.
    * rewrite tuple_3_1_eq.
      prove y = (x,y,z) 2 -> 1 = 2.
      rewrite tuple_3_2_eq. assume H1. apply Hyz H1.
  + apply cases_3 v Hv (fun v => (x,y,z) 2 = (x,y,z) v -> 2 = v).
    * rewrite tuple_3_2_eq.
      prove z = (x,y,z) 0 -> 2 = 0.
      rewrite tuple_3_0_eq. assume H1. apply Hxz.
      apply eq_sym set. exact H1.
    * rewrite tuple_3_2_eq.
      prove z = (x,y,z) 1 -> 2 = 1.
      rewrite tuple_3_1_eq. assume H1. apply Hyz.
      apply eq_sym set. exact H1.
    * assume _. apply eqI set.
Qed.

Theorem tuple_4_in_A_4 : forall x y z w A, x :e A -> y :e A -> z :e A -> w :e A -> (x,y,z,w) :e A :^: 4.
let x y z w A.
assume Hx Hy Hz Hw.
rewrite <- tuple_4_eta x y z w.
prove (fun i :e 4 => (x,y,z,w) i) :e Pi_ _ :e 4, A.
apply lam_Pi 4 (fun _ => A).
let i. assume Hi: i :e 4.
prove (x,y,z,w) i :e A.
apply cases_4 i Hi (fun i => (x,y,z,w) i :e A).
- prove (x,y,z,w) 0 :e A. rewrite tuple_4_0_eq. exact Hx.
- prove (x,y,z,w) 1 :e A. rewrite tuple_4_1_eq. exact Hy.
- prove (x,y,z,w) 2 :e A. rewrite tuple_4_2_eq. exact Hz.
- prove (x,y,z,w) 3 :e A. rewrite tuple_4_3_eq. exact Hw.
Qed.

Theorem tuple_4_bij_4 : forall x y z w, x :e 4 -> y :e 4 -> z :e 4 -> w :e 4 -> x <> y -> x <> z -> x <> w -> y <> z -> y <> w -> z <> w -> bij 4 4 (fun i => (x,y,z,w) i).
let x y z w. assume Hx Hy Hz Hw Hxy Hxz Hxw Hyz Hyw Hzw.
apply PigeonHole_nat_bij 4 (nat_ordsucc 3 (nat_ordsucc 2 nat_2)) (fun i => (x,y,z,w) i).
- let u. assume Hu. apply cases_4 u Hu (fun u => (x,y,z,w) u :e 4).
  + prove (x,y,z,w) 0 :e 4. rewrite tuple_4_0_eq. exact Hx.
  + prove (x,y,z,w) 1 :e 4. rewrite tuple_4_1_eq. exact Hy.
  + prove (x,y,z,w) 2 :e 4. rewrite tuple_4_2_eq. exact Hz.
  + prove (x,y,z,w) 3 :e 4. rewrite tuple_4_3_eq. exact Hw.
- let u. assume Hu. let v. assume Hv.
  apply cases_4 u Hu (fun u => (x,y,z,w) u = (x,y,z,w) v -> u = v).
  + apply cases_4 v Hv (fun v => (x,y,z,w) 0 = (x,y,z,w) v -> 0 = v).
    * assume _. apply eqI set.
    * rewrite tuple_4_0_eq.
      prove x = (x,y,z,w) 1 -> 0 = 1.
      rewrite tuple_4_1_eq. assume H1. apply Hxy H1.
    * rewrite tuple_4_0_eq.
      prove x = (x,y,z,w) 2 -> 0 = 2.
      rewrite tuple_4_2_eq. assume H1. apply Hxz H1.
    * rewrite tuple_4_0_eq.
      prove x = (x,y,z,w) 3 -> 0 = 3.
      rewrite tuple_4_3_eq. assume H1. apply Hxw H1.
  + apply cases_4 v Hv (fun v => (x,y,z,w) 1 = (x,y,z,w) v -> 1 = v).
    * rewrite tuple_4_1_eq.
      prove y = (x,y,z,w) 0 -> 1 = 0.
      rewrite tuple_4_0_eq. assume H1. apply Hxy.
      apply eq_sym set. exact H1.
    * assume _. apply eqI set.
    * rewrite tuple_4_1_eq.
      prove y = (x,y,z,w) 2 -> 1 = 2.
      rewrite tuple_4_2_eq. assume H1. apply Hyz H1.
    * rewrite tuple_4_1_eq.
      prove y = (x,y,z,w) 3 -> 1 = 3.
      rewrite tuple_4_3_eq. assume H1. apply Hyw H1.
  + apply cases_4 v Hv (fun v => (x,y,z,w) 2 = (x,y,z,w) v -> 2 = v).
    * rewrite tuple_4_2_eq.
      prove z = (x,y,z,w) 0 -> 2 = 0.
      rewrite tuple_4_0_eq. assume H1. apply Hxz.
      apply eq_sym set. exact H1.
    * rewrite tuple_4_2_eq.
      prove z = (x,y,z,w) 1 -> 2 = 1.
      rewrite tuple_4_1_eq. assume H1. apply Hyz.
      apply eq_sym set. exact H1.
    * assume _. apply eqI set.
    * rewrite tuple_4_2_eq.
      prove z = (x,y,z,w) 3 -> 2 = 3.
      rewrite tuple_4_3_eq. assume H1. apply Hzw H1.
  + apply cases_4 v Hv (fun v => (x,y,z,w) 3 = (x,y,z,w) v -> 3 = v).
    * rewrite tuple_4_3_eq.
      prove w = (x,y,z,w) 0 -> 3 = 0.
      rewrite tuple_4_0_eq. assume H1. apply Hxw.
      apply eq_sym set. exact H1.
    * rewrite tuple_4_3_eq.
      prove w = (x,y,z,w) 1 -> 3 = 1.
      rewrite tuple_4_1_eq. assume H1. apply Hyw.
      apply eq_sym set. exact H1.
    * rewrite tuple_4_3_eq.
      prove w = (x,y,z,w) 2 -> 3 = 2.
      rewrite tuple_4_2_eq. assume H1. apply Hzw.
      apply eq_sym set. exact H1.
    * assume _. apply eqI set.
Qed.

