Definition pack_c_b_u : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> set := fun X C f i => (X,encode_c X C,encode_b X f,encode_u X i).

Definition struct_c_b_u : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists f:set -> set -> set, exists i:set -> set, (forall x y :e X, f x y :e X) /\ (forall x :e X, i x :e X) /\ S = pack_c_b_u X C f i.

Theorem pack_c_b_u_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall i i':set -> set,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 pack_c_b_u X C f i = pack_c_b_u X C' f' i'.
let X C C' f f' i i'. assume H1. assume H2. assume H3.
prove (X,encode_c X C,encode_b X f,encode_u X i) = (X,encode_c X C',encode_b X f',encode_u X i').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_c_b_u_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, S = pack_c_b_u X C f i -> X = S 0.
let S X C f i. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_u X i) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_c_b_u_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, S = pack_c_b_u X C f i -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f i. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_u X i) 1) U.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_b_u_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, S = pack_c_b_u X C f i -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f i. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_u X i) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_c_b_u_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, S = pack_c_b_u X C f i -> forall x :e X, i x = decode_u (S 3) x.
let S X C f i. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_b X f,encode_u X i) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_struct_c_b_u: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, (forall x y :e X, f x y :e X) -> (forall x :e X, i x :e X) -> struct_c_b_u (pack_c_b_u X C f i).
let X C f i.
assume H2.
assume H3.
prove exists X':set, exists C':(set -> prop) -> prop, exists f':set -> set -> set, exists i':set -> set,  (forall x y :e X', f' x y :e X') /\ (forall x :e X', i' x :e X') /\ pack_c_b_u X C f i = pack_c_b_u X' C' f' i'.
witness X. witness C. witness f. witness i.
apply andI.
apply andI.
exact H2.
exact H3.
apply eqI set.
Qed.

Theorem struct_c_b_u_eta: forall S, struct_c_b_u S -> S = pack_c_b_u (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let f.
assume H3. apply H3. let i.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_b_u_0_eq S X C f i Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_b X (decode_b (S 2)),encode_u X (decode_u (S 3))).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_b_u_1_eq S X C f i Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_b X f = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_c_b_u_2_eq S X C f i Heq.
}
rewrite <- L2.
claim L3: encode_u X i = encode_u X (decode_u (S 3)).
{ apply encode_u_ext.
  exact struct_c_b_u_3_eq S X C f i Heq.
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_c_b_u.

Variable A:SType.

Definition unpack_c_b_u : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_u (S 3)).

Theorem unpack_c_b_u_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set) -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i i':set -> set, (forall x :e X, i x = i' x) -> Phi X C f i = Phi X C' f' i')
  ->
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall i:set -> set, unpack_c_b_u (pack_c_b_u X C f i) Phi = Phi X C f i.
let Phi.
assume HPhi.
let X C f i.
prove Phi (pack_c_b_u X C f i 0) (decode_c (pack_c_b_u X C f i 1)) (decode_b (pack_c_b_u X C f i 2)) (decode_u (pack_c_b_u X C f i 3)) = Phi X C f i.
rewrite <- struct_c_b_u_0_eq (pack_c_b_u X C f i) X C f i (eqI set (pack_c_b_u X C f i)).
prove Phi X (decode_c (pack_c_b_u X C f i 1)) (decode_b (pack_c_b_u X C f i 2)) (decode_u (pack_c_b_u X C f i 3)) = Phi X C f i.
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_b_u X C f i 1) U <-> C U.
  rewrite <- struct_c_b_u_1_eq (pack_c_b_u X C f i) X C f i (eqI set (pack_c_b_u X C f i)) U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_c_b_u X C f i 2) x y = f x y.
  apply eq_sym set.
  exact struct_c_b_u_2_eq (pack_c_b_u X C f i) X C f i (eqI set (pack_c_b_u X C f i)) x Hx y Hy.
- let x. assume Hx.
  prove decode_u (pack_c_b_u X C f i 3) x = i x.
  apply eq_sym set.
  exact struct_c_b_u_3_eq (pack_c_b_u X C f i) X C f i (eqI set (pack_c_b_u X C f i)) x Hx.
Qed.

End unpack_c_b_u.

Definition pack_c_b_r : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> set := fun X C f R => (X,encode_c X C,encode_b X f,encode_r X R).

Definition struct_c_b_r : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists f:set -> set -> set, exists R:set -> set -> prop, (forall x y :e X, f x y :e X) /\ S = pack_c_b_r X C f R.

Theorem pack_c_b_r_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall R R':set -> set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_c_b_r X C f R = pack_c_b_r X C' f' R'.
let X C C' f f' R R'. assume H1. assume H2. assume H3.
prove (X,encode_c X C,encode_b X f,encode_r X R) = (X,encode_c X C',encode_b X f',encode_r X R').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_c_b_r_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, S = pack_c_b_r X C f R -> X = S 0.
let S X C f R. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_r X R) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_c_b_r_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, S = pack_c_b_r X C f R -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f R. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_r X R) 1) U.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_b_r_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, S = pack_c_b_r X C f R -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_r X R) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_c_b_r_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, S = pack_c_b_r X C f R -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C f R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_b X f,encode_r X R) 3) x y.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_struct_c_b_r: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, (forall x y :e X, f x y :e X) -> struct_c_b_r (pack_c_b_r X C f R).
let X C f R.
assume H2.
prove exists X':set, exists C':(set -> prop) -> prop, exists f':set -> set -> set, exists R':set -> set -> prop,  (forall x y :e X', f' x y :e X') /\ pack_c_b_r X C f R = pack_c_b_r X' C' f' R'.
witness X. witness C. witness f. witness R.
apply andI.
exact H2.
apply eqI set.
Qed.

Theorem struct_c_b_r_eta: forall S, struct_c_b_r S -> S = pack_c_b_r (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let f.
assume H3. apply H3. let R.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_b_r_0_eq S X C f R Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_b X (decode_b (S 2)),encode_r X (decode_r (S 3))).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_b_r_1_eq S X C f R Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_b X f = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_c_b_r_2_eq S X C f R Heq.
}
rewrite <- L2.
claim L3: encode_r X R = encode_r X (decode_r (S 3)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_c_b_r_3_eq S X C f R Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_c_b_r.

Variable A:SType.

Definition unpack_c_b_r : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_r (S 3)).

Theorem unpack_c_b_r_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> set -> prop) -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X C f R = Phi X C' f' R')
  ->
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall R:set -> set -> prop, unpack_c_b_r (pack_c_b_r X C f R) Phi = Phi X C f R.
let Phi.
assume HPhi.
let X C f R.
prove Phi (pack_c_b_r X C f R 0) (decode_c (pack_c_b_r X C f R 1)) (decode_b (pack_c_b_r X C f R 2)) (decode_r (pack_c_b_r X C f R 3)) = Phi X C f R.
rewrite <- struct_c_b_r_0_eq (pack_c_b_r X C f R) X C f R (eqI set (pack_c_b_r X C f R)).
prove Phi X (decode_c (pack_c_b_r X C f R 1)) (decode_b (pack_c_b_r X C f R 2)) (decode_r (pack_c_b_r X C f R 3)) = Phi X C f R.
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_b_r X C f R 1) U <-> C U.
  rewrite <- struct_c_b_r_1_eq (pack_c_b_r X C f R) X C f R (eqI set (pack_c_b_r X C f R)) U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_c_b_r X C f R 2) x y = f x y.
  apply eq_sym set.
  exact struct_c_b_r_2_eq (pack_c_b_r X C f R) X C f R (eqI set (pack_c_b_r X C f R)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_c_b_r X C f R 3) x y <-> R x y.
  rewrite <- struct_c_b_r_3_eq (pack_c_b_r X C f R) X C f R (eqI set (pack_c_b_r X C f R)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_c_b_r.

Definition pack_c_b_p : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> prop) -> set := fun X C f P => (X,encode_c X C,encode_b X f,encode_p X P).

Definition struct_c_b_p : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists f:set -> set -> set, exists P:set -> prop, (forall x y :e X, f x y :e X) /\ S = pack_c_b_p X C f P.

Theorem pack_c_b_p_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall P P':set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_b_p X C f P = pack_c_b_p X C' f' P'.
let X C C' f f' P P'. assume H1. assume H2. assume H3.
prove (X,encode_c X C,encode_b X f,encode_p X P) = (X,encode_c X C',encode_b X f',encode_p X P').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_c_b_p_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, S = pack_c_b_p X C f P -> X = S 0.
let S X C f P. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,encode_p X P) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_c_b_p_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, S = pack_c_b_p X C f P -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f P. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,encode_p X P) 1) U.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_b_p_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, S = pack_c_b_p X C f P -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,encode_p X P) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_c_b_p_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, S = pack_c_b_p X C f P -> forall x :e X, P x = decode_p (S 3) x.
let S X C f P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_b X f,encode_p X P) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_c_b_p: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, (forall x y :e X, f x y :e X) -> struct_c_b_p (pack_c_b_p X C f P).
let X C f P.
assume H2.
prove exists X':set, exists C':(set -> prop) -> prop, exists f':set -> set -> set, exists P':set -> prop,  (forall x y :e X', f' x y :e X') /\ pack_c_b_p X C f P = pack_c_b_p X' C' f' P'.
witness X. witness C. witness f. witness P.
apply andI.
exact H2.
apply eqI set.
Qed.

Theorem struct_c_b_p_eta: forall S, struct_c_b_p S -> S = pack_c_b_p (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_p (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let f.
assume H3. apply H3. let P.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_b_p_0_eq S X C f P Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_b X (decode_b (S 2)),encode_p X (decode_p (S 3))).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_b_p_1_eq S X C f P Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_b X f = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_c_b_p_2_eq S X C f P Heq.
}
rewrite <- L2.
claim L3: encode_p X P = encode_p X (decode_p (S 3)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_c_b_p_3_eq S X C f P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_c_b_p.

Variable A:SType.

Definition unpack_c_b_p : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (decode_p (S 3)).

Theorem unpack_c_b_p_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> (set -> prop) -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C f P = Phi X C' f' P')
  ->
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall P:set -> prop, unpack_c_b_p (pack_c_b_p X C f P) Phi = Phi X C f P.
let Phi.
assume HPhi.
let X C f P.
prove Phi (pack_c_b_p X C f P 0) (decode_c (pack_c_b_p X C f P 1)) (decode_b (pack_c_b_p X C f P 2)) (decode_p (pack_c_b_p X C f P 3)) = Phi X C f P.
rewrite <- struct_c_b_p_0_eq (pack_c_b_p X C f P) X C f P (eqI set (pack_c_b_p X C f P)).
prove Phi X (decode_c (pack_c_b_p X C f P 1)) (decode_b (pack_c_b_p X C f P 2)) (decode_p (pack_c_b_p X C f P 3)) = Phi X C f P.
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_b_p X C f P 1) U <-> C U.
  rewrite <- struct_c_b_p_1_eq (pack_c_b_p X C f P) X C f P (eqI set (pack_c_b_p X C f P)) U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_c_b_p X C f P 2) x y = f x y.
  apply eq_sym set.
  exact struct_c_b_p_2_eq (pack_c_b_p X C f P) X C f P (eqI set (pack_c_b_p X C f P)) x Hx y Hy.
- let x. assume Hx.
  prove decode_p (pack_c_b_p X C f P 3) x <-> P x.
  rewrite <- struct_c_b_p_3_eq (pack_c_b_p X C f P) X C f P (eqI set (pack_c_b_p X C f P)) x Hx.
  apply iff_refl.
Qed.

End unpack_c_b_p.

Definition pack_c_b_e : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> set -> set := fun X C f c => (X,encode_c X C,encode_b X f,c).

Definition struct_c_b_e : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists f:set -> set -> set, exists c:set, (forall x y :e X, f x y :e X) /\ c :e X /\ S = pack_c_b_e X C f c.

Theorem pack_c_b_e_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 pack_c_b_e X C f c = pack_c_b_e X C' f' c.
let X C C' f f' c. assume H1. assume H2.
prove (X,encode_c X C,encode_b X f,c) = (X,encode_c X C',encode_b X f',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_c_b_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall c:set, S = pack_c_b_e X C f c -> X = S 0.
let S X C f c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_c_b_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall c:set, S = pack_c_b_e X C f c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f,c) 1) U.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_b_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall c:set, S = pack_c_b_e X C f c -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f,c) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_c_b_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall c:set, S = pack_c_b_e X C f c -> c = S 3.
let S X C f c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_b X f,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_c_b_e: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall c:set, (forall x y :e X, f x y :e X) -> c :e X -> struct_c_b_e (pack_c_b_e X C f c).
let X C f c.
assume H2.
assume H3.
prove exists X':set, exists C':(set -> prop) -> prop, exists f':set -> set -> set, exists c':set,  (forall x y :e X', f' x y :e X') /\ c' :e X' /\ pack_c_b_e X C f c = pack_c_b_e X' C' f' c'.
witness X. witness C. witness f. witness c.
apply andI.
apply andI.
exact H2.
exact H3.
apply eqI set.
Qed.

Theorem struct_c_b_e_eta: forall S, struct_c_b_e S -> S = pack_c_b_e (S 0) (decode_c (S 1)) (decode_b (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let f.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_b_e_0_eq S X C f c Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_b X (decode_b (S 2)),S 3).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_b_e_1_eq S X C f c Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_b X f = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_c_b_e_2_eq S X C f c Heq.
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_c_b_e_3_eq S X C f c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_c_b_e.

Variable A:SType.

Definition unpack_c_b_e : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)) (S 3).

Theorem unpack_c_b_e_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> set -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall c,Phi X C f c = Phi X C' f' c)
  ->
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, forall c:set, unpack_c_b_e (pack_c_b_e X C f c) Phi = Phi X C f c.
let Phi.
assume HPhi.
let X C f c.
prove Phi (pack_c_b_e X C f c 0) (decode_c (pack_c_b_e X C f c 1)) (decode_b (pack_c_b_e X C f c 2)) (pack_c_b_e X C f c 3) = Phi X C f c.
rewrite <- struct_c_b_e_0_eq (pack_c_b_e X C f c) X C f c (eqI set (pack_c_b_e X C f c)).
prove Phi X (decode_c (pack_c_b_e X C f c 1)) (decode_b (pack_c_b_e X C f c 2)) (pack_c_b_e X C f c 3) = Phi X C f c.
rewrite <- struct_c_b_e_3_eq (pack_c_b_e X C f c) X C f c (eqI set (pack_c_b_e X C f c)).
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_b_e X C f c 1) U <-> C U.
  rewrite <- struct_c_b_e_1_eq (pack_c_b_e X C f c) X C f c (eqI set (pack_c_b_e X C f c)) U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_c_b_e X C f c 2) x y = f x y.
  apply eq_sym set.
  exact struct_c_b_e_2_eq (pack_c_b_e X C f c) X C f c (eqI set (pack_c_b_e X C f c)) x Hx y Hy.
Qed.

End unpack_c_b_e.

Definition pack_c_u_r : set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> set := fun X C i R => (X,encode_c X C,encode_u X i,encode_r X R).

Definition struct_c_u_r : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists i:set -> set, exists R:set -> set -> prop, (forall x :e X, i x :e X) /\ S = pack_c_u_r X C i R.

Theorem pack_c_u_r_ext : forall X, forall C C':(set -> prop) -> prop, forall i i':set -> set, forall R R':set -> set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_c_u_r X C i R = pack_c_u_r X C' i' R'.
let X C C' i i' R R'. assume H1. assume H2. assume H3.
prove (X,encode_c X C,encode_u X i,encode_r X R) = (X,encode_c X C',encode_u X i',encode_r X R').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_c_u_r_0_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, S = pack_c_u_r X C i R -> X = S 0.
let S X C i R. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_u X i,encode_r X R) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_c_u_r_1_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, S = pack_c_u_r X C i R -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C i R. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_u X i,encode_r X R) 1) U.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_u_r_2_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, S = pack_c_u_r X C i R -> forall x :e X, i x = decode_u (S 2) x.
let S X C i R. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_u X i,encode_r X R) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_c_u_r_3_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, S = pack_c_u_r X C i R -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X C i R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_u X i,encode_r X R) 3) x y.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_struct_c_u_r: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, (forall x :e X, i x :e X) -> struct_c_u_r (pack_c_u_r X C i R).
let X C i R.
assume H2.
prove exists X':set, exists C':(set -> prop) -> prop, exists i':set -> set, exists R':set -> set -> prop,  (forall x :e X', i' x :e X') /\ pack_c_u_r X C i R = pack_c_u_r X' C' i' R'.
witness X. witness C. witness i. witness R.
apply andI.
exact H2.
apply eqI set.
Qed.

Theorem struct_c_u_r_eta: forall S, struct_c_u_r S -> S = pack_c_u_r (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let i.
assume H3. apply H3. let R.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_u_r_0_eq S X C i R Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_u X (decode_u (S 2)),encode_r X (decode_r (S 3))).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_u_r_1_eq S X C i R Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_u X i = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_c_u_r_2_eq S X C i R Heq.
}
rewrite <- L2.
claim L3: encode_r X R = encode_r X (decode_r (S 3)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_c_u_r_3_eq S X C i R Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_c_u_r.

Variable A:SType.

Definition unpack_c_u_r : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_r (S 3)).

Theorem unpack_c_u_r_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> set -> prop) -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X C i R = Phi X C' i' R')
  ->
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall R:set -> set -> prop, unpack_c_u_r (pack_c_u_r X C i R) Phi = Phi X C i R.
let Phi.
assume HPhi.
let X C i R.
prove Phi (pack_c_u_r X C i R 0) (decode_c (pack_c_u_r X C i R 1)) (decode_u (pack_c_u_r X C i R 2)) (decode_r (pack_c_u_r X C i R 3)) = Phi X C i R.
rewrite <- struct_c_u_r_0_eq (pack_c_u_r X C i R) X C i R (eqI set (pack_c_u_r X C i R)).
prove Phi X (decode_c (pack_c_u_r X C i R 1)) (decode_u (pack_c_u_r X C i R 2)) (decode_r (pack_c_u_r X C i R 3)) = Phi X C i R.
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_u_r X C i R 1) U <-> C U.
  rewrite <- struct_c_u_r_1_eq (pack_c_u_r X C i R) X C i R (eqI set (pack_c_u_r X C i R)) U HU.
  apply iff_refl.
- let x. assume Hx.
  prove decode_u (pack_c_u_r X C i R 2) x = i x.
  apply eq_sym set.
  exact struct_c_u_r_2_eq (pack_c_u_r X C i R) X C i R (eqI set (pack_c_u_r X C i R)) x Hx.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_c_u_r X C i R 3) x y <-> R x y.
  rewrite <- struct_c_u_r_3_eq (pack_c_u_r X C i R) X C i R (eqI set (pack_c_u_r X C i R)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_c_u_r.

Definition pack_c_u_p : set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> prop) -> set := fun X C i P => (X,encode_c X C,encode_u X i,encode_p X P).

Definition struct_c_u_p : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists i:set -> set, exists P:set -> prop, (forall x :e X, i x :e X) /\ S = pack_c_u_p X C i P.

Theorem pack_c_u_p_ext : forall X, forall C C':(set -> prop) -> prop, forall i i':set -> set, forall P P':set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_u_p X C i P = pack_c_u_p X C' i' P'.
let X C C' i i' P P'. assume H1. assume H2. assume H3.
prove (X,encode_c X C,encode_u X i,encode_p X P) = (X,encode_c X C',encode_u X i',encode_p X P').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_c_u_p_0_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, S = pack_c_u_p X C i P -> X = S 0.
let S X C i P. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_u X i,encode_p X P) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_c_u_p_1_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, S = pack_c_u_p X C i P -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C i P. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_u X i,encode_p X P) 1) U.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_u_p_2_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, S = pack_c_u_p X C i P -> forall x :e X, i x = decode_u (S 2) x.
let S X C i P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_u X i,encode_p X P) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_c_u_p_3_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, S = pack_c_u_p X C i P -> forall x :e X, P x = decode_p (S 3) x.
let S X C i P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_u X i,encode_p X P) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_c_u_p: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, (forall x :e X, i x :e X) -> struct_c_u_p (pack_c_u_p X C i P).
let X C i P.
assume H2.
prove exists X':set, exists C':(set -> prop) -> prop, exists i':set -> set, exists P':set -> prop,  (forall x :e X', i' x :e X') /\ pack_c_u_p X C i P = pack_c_u_p X' C' i' P'.
witness X. witness C. witness i. witness P.
apply andI.
exact H2.
apply eqI set.
Qed.

Theorem struct_c_u_p_eta: forall S, struct_c_u_p S -> S = pack_c_u_p (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_p (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let i.
assume H3. apply H3. let P.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_u_p_0_eq S X C i P Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_u X (decode_u (S 2)),encode_p X (decode_p (S 3))).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_u_p_1_eq S X C i P Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_u X i = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_c_u_p_2_eq S X C i P Heq.
}
rewrite <- L2.
claim L3: encode_p X P = encode_p X (decode_p (S 3)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_c_u_p_3_eq S X C i P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_c_u_p.

Variable A:SType.

Definition unpack_c_u_p : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (decode_p (S 3)).

Theorem unpack_c_u_p_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> (set -> prop) -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C i P = Phi X C' i' P')
  ->
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall P:set -> prop, unpack_c_u_p (pack_c_u_p X C i P) Phi = Phi X C i P.
let Phi.
assume HPhi.
let X C i P.
prove Phi (pack_c_u_p X C i P 0) (decode_c (pack_c_u_p X C i P 1)) (decode_u (pack_c_u_p X C i P 2)) (decode_p (pack_c_u_p X C i P 3)) = Phi X C i P.
rewrite <- struct_c_u_p_0_eq (pack_c_u_p X C i P) X C i P (eqI set (pack_c_u_p X C i P)).
prove Phi X (decode_c (pack_c_u_p X C i P 1)) (decode_u (pack_c_u_p X C i P 2)) (decode_p (pack_c_u_p X C i P 3)) = Phi X C i P.
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_u_p X C i P 1) U <-> C U.
  rewrite <- struct_c_u_p_1_eq (pack_c_u_p X C i P) X C i P (eqI set (pack_c_u_p X C i P)) U HU.
  apply iff_refl.
- let x. assume Hx.
  prove decode_u (pack_c_u_p X C i P 2) x = i x.
  apply eq_sym set.
  exact struct_c_u_p_2_eq (pack_c_u_p X C i P) X C i P (eqI set (pack_c_u_p X C i P)) x Hx.
- let x. assume Hx.
  prove decode_p (pack_c_u_p X C i P 3) x <-> P x.
  rewrite <- struct_c_u_p_3_eq (pack_c_u_p X C i P) X C i P (eqI set (pack_c_u_p X C i P)) x Hx.
  apply iff_refl.
Qed.

End unpack_c_u_p.

Definition pack_c_u_e : set -> ((set -> prop) -> prop) -> (set -> set) -> set -> set := fun X C i c => (X,encode_c X C,encode_u X i,c).

Definition struct_c_u_e : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists i:set -> set, exists c:set, (forall x :e X, i x :e X) /\ c :e X /\ S = pack_c_u_e X C i c.

Theorem pack_c_u_e_ext : forall X, forall C C':(set -> prop) -> prop, forall i i':set -> set, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, i x = i' x) ->
 pack_c_u_e X C i c = pack_c_u_e X C' i' c.
let X C C' i i' c. assume H1. assume H2.
prove (X,encode_c X C,encode_u X i,c) = (X,encode_c X C',encode_u X i',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_c_u_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall c:set, S = pack_c_u_e X C i c -> X = S 0.
let S X C i c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_u X i,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_c_u_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall c:set, S = pack_c_u_e X C i c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C i c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_u X i,c) 1) U.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_u_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall c:set, S = pack_c_u_e X C i c -> forall x :e X, i x = decode_u (S 2) x.
let S X C i c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_u X i,c) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_c_u_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, forall c:set, S = pack_c_u_e X C i c -> c = S 3.
let S X C i c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_u X i,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_c_u_e: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall c:set, (forall x :e X, i x :e X) -> c :e X -> struct_c_u_e (pack_c_u_e X C i c).
let X C i c.
assume H2.
assume H3.
prove exists X':set, exists C':(set -> prop) -> prop, exists i':set -> set, exists c':set,  (forall x :e X', i' x :e X') /\ c' :e X' /\ pack_c_u_e X C i c = pack_c_u_e X' C' i' c'.
witness X. witness C. witness i. witness c.
apply andI.
apply andI.
exact H2.
exact H3.
apply eqI set.
Qed.

Theorem struct_c_u_e_eta: forall S, struct_c_u_e S -> S = pack_c_u_e (S 0) (decode_c (S 1)) (decode_u (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let i.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_u_e_0_eq S X C i c Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_u X (decode_u (S 2)),S 3).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_u_e_1_eq S X C i c Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_u X i = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_c_u_e_2_eq S X C i c Heq.
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_c_u_e_3_eq S X C i c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_c_u_e.

Variable A:SType.

Definition unpack_c_u_e : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)) (S 3).

Theorem unpack_c_u_e_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> set -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall c,Phi X C i c = Phi X C' i' c)
  ->
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, forall c:set, unpack_c_u_e (pack_c_u_e X C i c) Phi = Phi X C i c.
let Phi.
assume HPhi.
let X C i c.
prove Phi (pack_c_u_e X C i c 0) (decode_c (pack_c_u_e X C i c 1)) (decode_u (pack_c_u_e X C i c 2)) (pack_c_u_e X C i c 3) = Phi X C i c.
rewrite <- struct_c_u_e_0_eq (pack_c_u_e X C i c) X C i c (eqI set (pack_c_u_e X C i c)).
prove Phi X (decode_c (pack_c_u_e X C i c 1)) (decode_u (pack_c_u_e X C i c 2)) (pack_c_u_e X C i c 3) = Phi X C i c.
rewrite <- struct_c_u_e_3_eq (pack_c_u_e X C i c) X C i c (eqI set (pack_c_u_e X C i c)).
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_u_e X C i c 1) U <-> C U.
  rewrite <- struct_c_u_e_1_eq (pack_c_u_e X C i c) X C i c (eqI set (pack_c_u_e X C i c)) U HU.
  apply iff_refl.
- let x. assume Hx.
  prove decode_u (pack_c_u_e X C i c 2) x = i x.
  apply eq_sym set.
  exact struct_c_u_e_2_eq (pack_c_u_e X C i c) X C i c (eqI set (pack_c_u_e X C i c)) x Hx.
Qed.

End unpack_c_u_e.

Definition pack_c_r_p : set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> (set -> prop) -> set := fun X C R P => (X,encode_c X C,encode_r X R,encode_p X P).

Definition struct_c_r_p : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists R:set -> set -> prop, exists P:set -> prop, S = pack_c_r_p X C R P.

Theorem pack_c_r_p_ext : forall X, forall C C':(set -> prop) -> prop, forall R R':set -> set -> prop, forall P P':set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_r_p X C R P = pack_c_r_p X C' R' P'.
let X C C' R R' P P'. assume H1. assume H2. assume H3.
prove (X,encode_c X C,encode_r X R,encode_p X P) = (X,encode_c X C',encode_r X R',encode_p X P').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_c_r_p_0_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_r_p X C R P -> X = S 0.
let S X C R P. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_r X R,encode_p X P) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_c_r_p_1_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_r_p X C R P -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C R P. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_r X R,encode_p X P) 1) U.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_r_p_2_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_r_p X C R P -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X C R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_r X R,encode_p X P) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_c_r_p_3_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, S = pack_c_r_p X C R P -> forall x :e X, P x = decode_p (S 3) x.
let S X C R P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_r X R,encode_p X P) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_c_r_p: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, struct_c_r_p (pack_c_r_p X C R P).
let X C R P.
prove exists X':set, exists C':(set -> prop) -> prop, exists R':set -> set -> prop, exists P':set -> prop,  pack_c_r_p X C R P = pack_c_r_p X' C' R' P'.
witness X. witness C. witness R. witness P.
apply eqI set.
Qed.

Theorem struct_c_r_p_eta: forall S, struct_c_r_p S -> S = pack_c_r_p (S 0) (decode_c (S 1)) (decode_r (S 2)) (decode_p (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let R.
assume H3. apply H3. let P.
assume Heq.
rewrite <- struct_c_r_p_0_eq S X C R P Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_r X (decode_r (S 2)),encode_p X (decode_p (S 3))).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_r_p_1_eq S X C R P Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_r X R = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_c_r_p_2_eq S X C R P Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L2.
claim L3: encode_p X P = encode_p X (decode_p (S 3)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_c_r_p_3_eq S X C R P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_c_r_p.

Variable A:SType.

Definition unpack_c_r_p : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_r (S 2)) (decode_p (S 3)).

Theorem unpack_c_r_p_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> (set -> prop) -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C R P = Phi X C' R' P')
  ->
  forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall P:set -> prop, unpack_c_r_p (pack_c_r_p X C R P) Phi = Phi X C R P.
let Phi.
assume HPhi.
let X C R P.
prove Phi (pack_c_r_p X C R P 0) (decode_c (pack_c_r_p X C R P 1)) (decode_r (pack_c_r_p X C R P 2)) (decode_p (pack_c_r_p X C R P 3)) = Phi X C R P.
rewrite <- struct_c_r_p_0_eq (pack_c_r_p X C R P) X C R P (eqI set (pack_c_r_p X C R P)).
prove Phi X (decode_c (pack_c_r_p X C R P 1)) (decode_r (pack_c_r_p X C R P 2)) (decode_p (pack_c_r_p X C R P 3)) = Phi X C R P.
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_r_p X C R P 1) U <-> C U.
  rewrite <- struct_c_r_p_1_eq (pack_c_r_p X C R P) X C R P (eqI set (pack_c_r_p X C R P)) U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_c_r_p X C R P 2) x y <-> R x y.
  rewrite <- struct_c_r_p_2_eq (pack_c_r_p X C R P) X C R P (eqI set (pack_c_r_p X C R P)) x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove decode_p (pack_c_r_p X C R P 3) x <-> P x.
  rewrite <- struct_c_r_p_3_eq (pack_c_r_p X C R P) X C R P (eqI set (pack_c_r_p X C R P)) x Hx.
  apply iff_refl.
Qed.

End unpack_c_r_p.

Definition pack_c_r_e : set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> set -> set := fun X C R c => (X,encode_c X C,encode_r X R,c).

Definition struct_c_r_e : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists R:set -> set -> prop, exists c:set, c :e X /\ S = pack_c_r_e X C R c.

Theorem pack_c_r_e_ext : forall X, forall C C':(set -> prop) -> prop, forall R R':set -> set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_c_r_e X C R c = pack_c_r_e X C' R' c.
let X C C' R R' c. assume H1. assume H2.
prove (X,encode_c X C,encode_r X R,c) = (X,encode_c X C',encode_r X R',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_c_r_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall c:set, S = pack_c_r_e X C R c -> X = S 0.
let S X C R c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_r X R,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_c_r_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall c:set, S = pack_c_r_e X C R c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C R c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_r X R,c) 1) U.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_r_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall c:set, S = pack_c_r_e X C R c -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X C R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_r X R,c) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_c_r_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall c:set, S = pack_c_r_e X C R c -> c = S 3.
let S X C R c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_r X R,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_c_r_e: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall c:set, c :e X -> struct_c_r_e (pack_c_r_e X C R c).
let X C R c.
assume H3.
prove exists X':set, exists C':(set -> prop) -> prop, exists R':set -> set -> prop, exists c':set,  c' :e X' /\ pack_c_r_e X C R c = pack_c_r_e X' C' R' c'.
witness X. witness C. witness R. witness c.
apply andI.
exact H3.
apply eqI set.
Qed.

Theorem struct_c_r_e_eta: forall S, struct_c_r_e S -> S = pack_c_r_e (S 0) (decode_c (S 1)) (decode_r (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let R.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_r_e_0_eq S X C R c Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_r X (decode_r (S 2)),S 3).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_r_e_1_eq S X C R c Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_r X R = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_c_r_e_2_eq S X C R c Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_c_r_e_3_eq S X C R c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_c_r_e.

Variable A:SType.

Definition unpack_c_r_e : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_r (S 2)) (S 3).

Theorem unpack_c_r_e_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> set -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall c,Phi X C R c = Phi X C' R' c)
  ->
  forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, forall c:set, unpack_c_r_e (pack_c_r_e X C R c) Phi = Phi X C R c.
let Phi.
assume HPhi.
let X C R c.
prove Phi (pack_c_r_e X C R c 0) (decode_c (pack_c_r_e X C R c 1)) (decode_r (pack_c_r_e X C R c 2)) (pack_c_r_e X C R c 3) = Phi X C R c.
rewrite <- struct_c_r_e_0_eq (pack_c_r_e X C R c) X C R c (eqI set (pack_c_r_e X C R c)).
prove Phi X (decode_c (pack_c_r_e X C R c 1)) (decode_r (pack_c_r_e X C R c 2)) (pack_c_r_e X C R c 3) = Phi X C R c.
rewrite <- struct_c_r_e_3_eq (pack_c_r_e X C R c) X C R c (eqI set (pack_c_r_e X C R c)).
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_r_e X C R c 1) U <-> C U.
  rewrite <- struct_c_r_e_1_eq (pack_c_r_e X C R c) X C R c (eqI set (pack_c_r_e X C R c)) U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_c_r_e X C R c 2) x y <-> R x y.
  rewrite <- struct_c_r_e_2_eq (pack_c_r_e X C R c) X C R c (eqI set (pack_c_r_e X C R c)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_c_r_e.

Definition pack_c_p_e : set -> ((set -> prop) -> prop) -> (set -> prop) -> set -> set := fun X C P c => (X,encode_c X C,encode_p X P,c).

Definition struct_c_p_e : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists P:set -> prop, exists c:set, c :e X /\ S = pack_c_p_e X C P c.

Theorem pack_c_p_e_ext : forall X, forall C C':(set -> prop) -> prop, forall P P':set -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_p_e X C P c = pack_c_p_e X C' P' c.
let X C C' P P' c. assume H1. assume H2.
prove (X,encode_c X C,encode_p X P,c) = (X,encode_c X C',encode_p X P',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_c_p_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall P:set -> prop, forall c:set, S = pack_c_p_e X C P c -> X = S 0.
let S X C P c. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_p X P,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_c_p_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall P:set -> prop, forall c:set, S = pack_c_p_e X C P c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C P c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_p X P,c) 1) U.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_p_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall P:set -> prop, forall c:set, S = pack_c_p_e X C P c -> forall x :e X, P x = decode_p (S 2) x.
let S X C P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_p X P,c) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem struct_c_p_e_3_eq: forall S X, forall C:(set -> prop) -> prop, forall P:set -> prop, forall c:set, S = pack_c_p_e X C P c -> c = S 3.
let S X C P c. assume H1.
rewrite H1. prove c = (X,encode_c X C,encode_p X P,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_c_p_e: forall X, forall C:(set -> prop) -> prop, forall P:set -> prop, forall c:set, c :e X -> struct_c_p_e (pack_c_p_e X C P c).
let X C P c.
assume H3.
prove exists X':set, exists C':(set -> prop) -> prop, exists P':set -> prop, exists c':set,  c' :e X' /\ pack_c_p_e X C P c = pack_c_p_e X' C' P' c'.
witness X. witness C. witness P. witness c.
apply andI.
exact H3.
apply eqI set.
Qed.

Theorem struct_c_p_e_eta: forall S, struct_c_p_e S -> S = pack_c_p_e (S 0) (decode_c (S 1)) (decode_p (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let P.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_p_e_0_eq S X C P c Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_p X (decode_p (S 2)),S 3).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_p_e_1_eq S X C P c Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_p X P = encode_p X (decode_p (S 2)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_c_p_e_2_eq S X C P c Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_c_p_e_3_eq S X C P c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_c_p_e.

Variable A:SType.

Definition unpack_c_p_e : set -> (set -> ((set -> prop) -> prop) -> (set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_p (S 2)) (S 3).

Theorem unpack_c_p_e_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> prop) -> set -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall c,Phi X C P c = Phi X C' P' c)
  ->
  forall X, forall C:(set -> prop) -> prop, forall P:set -> prop, forall c:set, unpack_c_p_e (pack_c_p_e X C P c) Phi = Phi X C P c.
let Phi.
assume HPhi.
let X C P c.
prove Phi (pack_c_p_e X C P c 0) (decode_c (pack_c_p_e X C P c 1)) (decode_p (pack_c_p_e X C P c 2)) (pack_c_p_e X C P c 3) = Phi X C P c.
rewrite <- struct_c_p_e_0_eq (pack_c_p_e X C P c) X C P c (eqI set (pack_c_p_e X C P c)).
prove Phi X (decode_c (pack_c_p_e X C P c 1)) (decode_p (pack_c_p_e X C P c 2)) (pack_c_p_e X C P c 3) = Phi X C P c.
rewrite <- struct_c_p_e_3_eq (pack_c_p_e X C P c) X C P c (eqI set (pack_c_p_e X C P c)).
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_p_e X C P c 1) U <-> C U.
  rewrite <- struct_c_p_e_1_eq (pack_c_p_e X C P c) X C P c (eqI set (pack_c_p_e X C P c)) U HU.
  apply iff_refl.
- let x. assume Hx.
  prove decode_p (pack_c_p_e X C P c 2) x <-> P x.
  rewrite <- struct_c_p_e_2_eq (pack_c_p_e X C P c) X C P c (eqI set (pack_c_p_e X C P c)) x Hx.
  apply iff_refl.
Qed.

End unpack_c_p_e.

Definition pack_b_b_b : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> set := fun X f g h => (X,encode_b X f,encode_b X g,encode_b X h).

Definition struct_b_b_b : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists g:set -> set -> set, exists h:set -> set -> set, (forall x y :e X, f x y :e X) /\ (forall x y :e X, g x y :e X) /\ (forall x y :e X, h x y :e X) /\ S = pack_b_b_b X f g h.

Theorem pack_b_b_b_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall h h':set -> set -> set,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, h x y = h' x y) ->
 pack_b_b_b X f g h = pack_b_b_b X f' g' h'.
let X f f' g g' h h'. assume H1. assume H2. assume H3.
prove (X,encode_b X f,encode_b X g,encode_b X h) = (X,encode_b X f',encode_b X g',encode_b X h').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_b X h = encode_b X h'.
{ apply encode_b_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_b_b_b_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, S = pack_b_b_b X f g h -> X = S 0.
let S X f g h. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_b X h) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_b_b_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, S = pack_b_b_b X f g h -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g h. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_b_b_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, S = pack_b_b_b X f g h -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g h. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym set. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem struct_b_b_b_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, S = pack_b_b_b X f g h -> forall x y :e X, h x y = decode_b (S 3) x y.
let S X f g h. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove h x y = decode_b ((X,encode_b X f,encode_b X g,encode_b X h) 3) x y.
rewrite tuple_4_3_eq.
apply eq_sym set. exact decode_encode_b X h x Hx y Hy.
Qed.

Theorem pack_struct_b_b_b: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, (forall x y :e X, f x y :e X) -> (forall x y :e X, g x y :e X) -> (forall x y :e X, h x y :e X) -> struct_b_b_b (pack_b_b_b X f g h).
let X f g h.
assume H1.
assume H2.
assume H3.
prove exists X':set, exists f':set -> set -> set, exists g':set -> set -> set, exists h':set -> set -> set,  (forall x y :e X', f' x y :e X') /\ (forall x y :e X', g' x y :e X') /\ (forall x y :e X', h' x y :e X') /\ pack_b_b_b X f g h = pack_b_b_b X' f' g' h'.
witness X. witness f. witness g. witness h.
apply andI.
apply andI.
apply andI.
exact H1.
exact H2.
exact H3.
apply eqI set.
Qed.

Theorem struct_b_b_b_eta: forall S, struct_b_b_b S -> S = pack_b_b_b (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let g.
assume H3. apply H3. let h.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_b_b_0_eq S X f g h Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_b X (decode_b (S 2)),encode_b X (decode_b (S 3))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_b_b_1_eq S X f g h Heq.
}
rewrite <- L1.
claim L2: encode_b X g = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_b_b_b_2_eq S X f g h Heq.
}
rewrite <- L2.
claim L3: encode_b X h = encode_b X (decode_b (S 3)).
{ apply encode_b_ext.
  exact struct_b_b_b_3_eq S X f g h Heq.
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_b_b.

Variable A:SType.

Definition unpack_b_b_b : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_b (S 3)).

Theorem unpack_b_b_b_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> set) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall h h':set -> set -> set, (forall x y :e X, h x y = h' x y) -> Phi X f g h = Phi X f' g' h')
  ->
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall h:set -> set -> set, unpack_b_b_b (pack_b_b_b X f g h) Phi = Phi X f g h.
let Phi.
assume HPhi.
let X f g h.
prove Phi (pack_b_b_b X f g h 0) (decode_b (pack_b_b_b X f g h 1)) (decode_b (pack_b_b_b X f g h 2)) (decode_b (pack_b_b_b X f g h 3)) = Phi X f g h.
rewrite <- struct_b_b_b_0_eq (pack_b_b_b X f g h) X f g h (eqI set (pack_b_b_b X f g h)).
prove Phi X (decode_b (pack_b_b_b X f g h 1)) (decode_b (pack_b_b_b X f g h 2)) (decode_b (pack_b_b_b X f g h 3)) = Phi X f g h.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_b X f g h 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_b_b_1_eq (pack_b_b_b X f g h) X f g h (eqI set (pack_b_b_b X f g h)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_b X f g h 2) x y = g x y.
  apply eq_sym set.
  exact struct_b_b_b_2_eq (pack_b_b_b X f g h) X f g h (eqI set (pack_b_b_b X f g h)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_b X f g h 3) x y = h x y.
  apply eq_sym set.
  exact struct_b_b_b_3_eq (pack_b_b_b X f g h) X f g h (eqI set (pack_b_b_b X f g h)) x Hx y Hy.
Qed.

End unpack_b_b_b.

Definition pack_b_b_u : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> set := fun X f g i => (X,encode_b X f,encode_b X g,encode_u X i).

Definition struct_b_b_u : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists g:set -> set -> set, exists i:set -> set, (forall x y :e X, f x y :e X) /\ (forall x y :e X, g x y :e X) /\ (forall x :e X, i x :e X) /\ S = pack_b_b_u X f g i.

Theorem pack_b_b_u_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall i i':set -> set,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, i x = i' x) ->
 pack_b_b_u X f g i = pack_b_b_u X f' g' i'.
let X f f' g g' i i'. assume H1. assume H2. assume H3.
prove (X,encode_b X f,encode_b X g,encode_u X i) = (X,encode_b X f',encode_b X g',encode_u X i').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_b_b_u_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, S = pack_b_b_u X f g i -> X = S 0.
let S X f g i. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_u X i) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_b_u_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, S = pack_b_b_u X f g i -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g i. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_b_u_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, S = pack_b_b_u X f g i -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g i. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_u X i) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym set. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem struct_b_b_u_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, S = pack_b_b_u X f g i -> forall x :e X, i x = decode_u (S 3) x.
let S X f g i. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_b X g,encode_u X i) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_struct_b_b_u: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, (forall x y :e X, f x y :e X) -> (forall x y :e X, g x y :e X) -> (forall x :e X, i x :e X) -> struct_b_b_u (pack_b_b_u X f g i).
let X f g i.
assume H1.
assume H2.
assume H3.
prove exists X':set, exists f':set -> set -> set, exists g':set -> set -> set, exists i':set -> set,  (forall x y :e X', f' x y :e X') /\ (forall x y :e X', g' x y :e X') /\ (forall x :e X', i' x :e X') /\ pack_b_b_u X f g i = pack_b_b_u X' f' g' i'.
witness X. witness f. witness g. witness i.
apply andI.
apply andI.
apply andI.
exact H1.
exact H2.
exact H3.
apply eqI set.
Qed.

Theorem struct_b_b_u_eta: forall S, struct_b_b_u S -> S = pack_b_b_u (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let g.
assume H3. apply H3. let i.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_b_u_0_eq S X f g i Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_b X (decode_b (S 2)),encode_u X (decode_u (S 3))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_b_u_1_eq S X f g i Heq.
}
rewrite <- L1.
claim L2: encode_b X g = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_b_b_u_2_eq S X f g i Heq.
}
rewrite <- L2.
claim L3: encode_u X i = encode_u X (decode_u (S 3)).
{ apply encode_u_ext.
  exact struct_b_b_u_3_eq S X f g i Heq.
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_b_u.

Variable A:SType.

Definition unpack_b_b_u : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_u (S 3)).

Theorem unpack_b_b_u_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall i i':set -> set, (forall x :e X, i x = i' x) -> Phi X f g i = Phi X f' g' i')
  ->
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall i:set -> set, unpack_b_b_u (pack_b_b_u X f g i) Phi = Phi X f g i.
let Phi.
assume HPhi.
let X f g i.
prove Phi (pack_b_b_u X f g i 0) (decode_b (pack_b_b_u X f g i 1)) (decode_b (pack_b_b_u X f g i 2)) (decode_u (pack_b_b_u X f g i 3)) = Phi X f g i.
rewrite <- struct_b_b_u_0_eq (pack_b_b_u X f g i) X f g i (eqI set (pack_b_b_u X f g i)).
prove Phi X (decode_b (pack_b_b_u X f g i 1)) (decode_b (pack_b_b_u X f g i 2)) (decode_u (pack_b_b_u X f g i 3)) = Phi X f g i.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_u X f g i 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_b_u_1_eq (pack_b_b_u X f g i) X f g i (eqI set (pack_b_b_u X f g i)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_u X f g i 2) x y = g x y.
  apply eq_sym set.
  exact struct_b_b_u_2_eq (pack_b_b_u X f g i) X f g i (eqI set (pack_b_b_u X f g i)) x Hx y Hy.
- let x. assume Hx.
  prove decode_u (pack_b_b_u X f g i 3) x = i x.
  apply eq_sym set.
  exact struct_b_b_u_3_eq (pack_b_b_u X f g i) X f g i (eqI set (pack_b_b_u X f g i)) x Hx.
Qed.

End unpack_b_b_u.

Definition pack_b_b_r : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> set := fun X f g R => (X,encode_b X f,encode_b X g,encode_r X R).

Definition struct_b_b_r : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists g:set -> set -> set, exists R:set -> set -> prop, (forall x y :e X, f x y :e X) /\ (forall x y :e X, g x y :e X) /\ S = pack_b_b_r X f g R.

Theorem pack_b_b_r_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall R R':set -> set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_b_b_r X f g R = pack_b_b_r X f' g' R'.
let X f f' g g' R R'. assume H1. assume H2. assume H3.
prove (X,encode_b X f,encode_b X g,encode_r X R) = (X,encode_b X f',encode_b X g',encode_r X R').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_b_b_r_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, S = pack_b_b_r X f g R -> X = S 0.
let S X f g R. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_r X R) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_b_r_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, S = pack_b_b_r X f g R -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_b_r_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, S = pack_b_b_r X f g R -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_r X R) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym set. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem struct_b_b_r_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, S = pack_b_b_r X f g R -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f g R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_b X g,encode_r X R) 3) x y.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_struct_b_b_r: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, (forall x y :e X, f x y :e X) -> (forall x y :e X, g x y :e X) -> struct_b_b_r (pack_b_b_r X f g R).
let X f g R.
assume H1.
assume H2.
prove exists X':set, exists f':set -> set -> set, exists g':set -> set -> set, exists R':set -> set -> prop,  (forall x y :e X', f' x y :e X') /\ (forall x y :e X', g' x y :e X') /\ pack_b_b_r X f g R = pack_b_b_r X' f' g' R'.
witness X. witness f. witness g. witness R.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_b_b_r_eta: forall S, struct_b_b_r S -> S = pack_b_b_r (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let g.
assume H3. apply H3. let R.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_b_r_0_eq S X f g R Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_b X (decode_b (S 2)),encode_r X (decode_r (S 3))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_b_r_1_eq S X f g R Heq.
}
rewrite <- L1.
claim L2: encode_b X g = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_b_b_r_2_eq S X f g R Heq.
}
rewrite <- L2.
claim L3: encode_r X R = encode_r X (decode_r (S 3)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_b_b_r_3_eq S X f g R Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_b_r.

Variable A:SType.

Definition unpack_b_b_r : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_r (S 3)).

Theorem unpack_b_b_r_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> set -> prop) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f g R = Phi X f' g' R')
  ->
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall R:set -> set -> prop, unpack_b_b_r (pack_b_b_r X f g R) Phi = Phi X f g R.
let Phi.
assume HPhi.
let X f g R.
prove Phi (pack_b_b_r X f g R 0) (decode_b (pack_b_b_r X f g R 1)) (decode_b (pack_b_b_r X f g R 2)) (decode_r (pack_b_b_r X f g R 3)) = Phi X f g R.
rewrite <- struct_b_b_r_0_eq (pack_b_b_r X f g R) X f g R (eqI set (pack_b_b_r X f g R)).
prove Phi X (decode_b (pack_b_b_r X f g R 1)) (decode_b (pack_b_b_r X f g R 2)) (decode_r (pack_b_b_r X f g R 3)) = Phi X f g R.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_r X f g R 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_b_r_1_eq (pack_b_b_r X f g R) X f g R (eqI set (pack_b_b_r X f g R)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_r X f g R 2) x y = g x y.
  apply eq_sym set.
  exact struct_b_b_r_2_eq (pack_b_b_r X f g R) X f g R (eqI set (pack_b_b_r X f g R)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_b_b_r X f g R 3) x y <-> R x y.
  rewrite <- struct_b_b_r_3_eq (pack_b_b_r X f g R) X f g R (eqI set (pack_b_b_r X f g R)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_b_b_r.

Definition pack_b_b_p : set -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> set := fun X f g P => (X,encode_b X f,encode_b X g,encode_p X P).

Definition struct_b_b_p : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists g:set -> set -> set, exists P:set -> prop, (forall x y :e X, f x y :e X) /\ (forall x y :e X, g x y :e X) /\ S = pack_b_b_p X f g P.

Theorem pack_b_b_p_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall P P':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_b_p X f g P = pack_b_b_p X f' g' P'.
let X f f' g g' P P'. assume H1. assume H2. assume H3.
prove (X,encode_b X f,encode_b X g,encode_p X P) = (X,encode_b X f',encode_b X g',encode_p X P').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_b_b_p_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, S = pack_b_b_p X f g P -> X = S 0.
let S X f g P. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,encode_p X P) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_b_p_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, S = pack_b_b_p X f g P -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,encode_p X P) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_b_p_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, S = pack_b_b_p X f g P -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,encode_p X P) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym set. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem struct_b_b_p_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, S = pack_b_b_p X f g P -> forall x :e X, P x = decode_p (S 3) x.
let S X f g P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_b X g,encode_p X P) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_b_b_p: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, (forall x y :e X, f x y :e X) -> (forall x y :e X, g x y :e X) -> struct_b_b_p (pack_b_b_p X f g P).
let X f g P.
assume H1.
assume H2.
prove exists X':set, exists f':set -> set -> set, exists g':set -> set -> set, exists P':set -> prop,  (forall x y :e X', f' x y :e X') /\ (forall x y :e X', g' x y :e X') /\ pack_b_b_p X f g P = pack_b_b_p X' f' g' P'.
witness X. witness f. witness g. witness P.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_b_b_p_eta: forall S, struct_b_b_p S -> S = pack_b_b_p (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_p (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let g.
assume H3. apply H3. let P.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_b_p_0_eq S X f g P Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_b X (decode_b (S 2)),encode_p X (decode_p (S 3))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_b_p_1_eq S X f g P Heq.
}
rewrite <- L1.
claim L2: encode_b X g = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_b_b_p_2_eq S X f g P Heq.
}
rewrite <- L2.
claim L3: encode_p X P = encode_p X (decode_p (S 3)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_b_b_p_3_eq S X f g P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_b_p.

Variable A:SType.

Definition unpack_b_b_p : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (decode_p (S 3)).

Theorem unpack_b_b_p_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> (set -> prop) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f g P = Phi X f' g' P')
  ->
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall P:set -> prop, unpack_b_b_p (pack_b_b_p X f g P) Phi = Phi X f g P.
let Phi.
assume HPhi.
let X f g P.
prove Phi (pack_b_b_p X f g P 0) (decode_b (pack_b_b_p X f g P 1)) (decode_b (pack_b_b_p X f g P 2)) (decode_p (pack_b_b_p X f g P 3)) = Phi X f g P.
rewrite <- struct_b_b_p_0_eq (pack_b_b_p X f g P) X f g P (eqI set (pack_b_b_p X f g P)).
prove Phi X (decode_b (pack_b_b_p X f g P 1)) (decode_b (pack_b_b_p X f g P 2)) (decode_p (pack_b_b_p X f g P 3)) = Phi X f g P.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_p X f g P 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_b_p_1_eq (pack_b_b_p X f g P) X f g P (eqI set (pack_b_b_p X f g P)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_p X f g P 2) x y = g x y.
  apply eq_sym set.
  exact struct_b_b_p_2_eq (pack_b_b_p X f g P) X f g P (eqI set (pack_b_b_p X f g P)) x Hx y Hy.
- let x. assume Hx.
  prove decode_p (pack_b_b_p X f g P 3) x <-> P x.
  rewrite <- struct_b_b_p_3_eq (pack_b_b_p X f g P) X f g P (eqI set (pack_b_b_p X f g P)) x Hx.
  apply iff_refl.
Qed.

End unpack_b_b_p.

Definition pack_b_b_e : set -> (set -> set -> set) -> (set -> set -> set) -> set -> set := fun X f g c => (X,encode_b X f,encode_b X g,c).

Definition struct_b_b_e : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists g:set -> set -> set, exists c:set, (forall x y :e X, f x y :e X) /\ (forall x y :e X, g x y :e X) /\ c :e X /\ S = pack_b_b_e X f g c.

Theorem pack_b_b_e_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 pack_b_b_e X f g c = pack_b_b_e X f' g' c.
let X f f' g g' c. assume H1. assume H2.
prove (X,encode_b X f,encode_b X g,c) = (X,encode_b X f',encode_b X g',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_b_b_e_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall c:set, S = pack_b_b_e X f g c -> X = S 0.
let S X f g c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_b_e_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall c:set, S = pack_b_b_e X f g c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g,c) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_b_e_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall c:set, S = pack_b_b_e X f g c -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g,c) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym set. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem struct_b_b_e_3_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, forall c:set, S = pack_b_b_e X f g c -> c = S 3.
let S X f g c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_b X g,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_b_b_e: forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall c:set, (forall x y :e X, f x y :e X) -> (forall x y :e X, g x y :e X) -> c :e X -> struct_b_b_e (pack_b_b_e X f g c).
let X f g c.
assume H1.
assume H2.
assume H3.
prove exists X':set, exists f':set -> set -> set, exists g':set -> set -> set, exists c':set,  (forall x y :e X', f' x y :e X') /\ (forall x y :e X', g' x y :e X') /\ c' :e X' /\ pack_b_b_e X f g c = pack_b_b_e X' f' g' c'.
witness X. witness f. witness g. witness c.
apply andI.
apply andI.
apply andI.
exact H1.
exact H2.
exact H3.
apply eqI set.
Qed.

Theorem struct_b_b_e_eta: forall S, struct_b_b_e S -> S = pack_b_b_e (S 0) (decode_b (S 1)) (decode_b (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let g.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_b_e_0_eq S X f g c Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_b X (decode_b (S 2)),S 3).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_b_e_1_eq S X f g c Heq.
}
rewrite <- L1.
claim L2: encode_b X g = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_b_b_e_2_eq S X f g c Heq.
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_b_b_e_3_eq S X f g c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_b_e.

Variable A:SType.

Definition unpack_b_b_e : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)) (S 3).

Theorem unpack_b_b_e_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> set -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g g':set -> set -> set, (forall x y :e X, g x y = g' x y) ->  forall c,Phi X f g c = Phi X f' g' c)
  ->
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, forall c:set, unpack_b_b_e (pack_b_b_e X f g c) Phi = Phi X f g c.
let Phi.
assume HPhi.
let X f g c.
prove Phi (pack_b_b_e X f g c 0) (decode_b (pack_b_b_e X f g c 1)) (decode_b (pack_b_b_e X f g c 2)) (pack_b_b_e X f g c 3) = Phi X f g c.
rewrite <- struct_b_b_e_0_eq (pack_b_b_e X f g c) X f g c (eqI set (pack_b_b_e X f g c)).
prove Phi X (decode_b (pack_b_b_e X f g c 1)) (decode_b (pack_b_b_e X f g c 2)) (pack_b_b_e X f g c 3) = Phi X f g c.
rewrite <- struct_b_b_e_3_eq (pack_b_b_e X f g c) X f g c (eqI set (pack_b_b_e X f g c)).
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_e X f g c 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_b_e_1_eq (pack_b_b_e X f g c) X f g c (eqI set (pack_b_b_e X f g c)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b_e X f g c 2) x y = g x y.
  apply eq_sym set.
  exact struct_b_b_e_2_eq (pack_b_b_e X f g c) X f g c (eqI set (pack_b_b_e X f g c)) x Hx y Hy.
Qed.

End unpack_b_b_e.

Definition pack_b_u_r : set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> set := fun X f i R => (X,encode_b X f,encode_u X i,encode_r X R).

Definition struct_b_u_r : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists i:set -> set, exists R:set -> set -> prop, (forall x y :e X, f x y :e X) /\ (forall x :e X, i x :e X) /\ S = pack_b_u_r X f i R.

Theorem pack_b_u_r_ext : forall X, forall f f':set -> set -> set, forall i i':set -> set, forall R R':set -> set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_b_u_r X f i R = pack_b_u_r X f' i' R'.
let X f f' i i' R R'. assume H1. assume H2. assume H3.
prove (X,encode_b X f,encode_u X i,encode_r X R) = (X,encode_b X f',encode_u X i',encode_r X R').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_b_u_r_0_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, S = pack_b_u_r X f i R -> X = S 0.
let S X f i R. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_u X i,encode_r X R) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_u_r_1_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, S = pack_b_u_r X f i R -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f i R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_u X i,encode_r X R) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_u_r_2_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, S = pack_b_u_r X f i R -> forall x :e X, i x = decode_u (S 2) x.
let S X f i R. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_u X i,encode_r X R) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_b_u_r_3_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, S = pack_b_u_r X f i R -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X f i R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_u X i,encode_r X R) 3) x y.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_struct_b_u_r: forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, (forall x y :e X, f x y :e X) -> (forall x :e X, i x :e X) -> struct_b_u_r (pack_b_u_r X f i R).
let X f i R.
assume H1.
assume H2.
prove exists X':set, exists f':set -> set -> set, exists i':set -> set, exists R':set -> set -> prop,  (forall x y :e X', f' x y :e X') /\ (forall x :e X', i' x :e X') /\ pack_b_u_r X f i R = pack_b_u_r X' f' i' R'.
witness X. witness f. witness i. witness R.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_b_u_r_eta: forall S, struct_b_u_r S -> S = pack_b_u_r (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let i.
assume H3. apply H3. let R.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_u_r_0_eq S X f i R Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_u X (decode_u (S 2)),encode_r X (decode_r (S 3))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_u_r_1_eq S X f i R Heq.
}
rewrite <- L1.
claim L2: encode_u X i = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_b_u_r_2_eq S X f i R Heq.
}
rewrite <- L2.
claim L3: encode_r X R = encode_r X (decode_r (S 3)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_b_u_r_3_eq S X f i R Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_u_r.

Variable A:SType.

Definition unpack_b_u_r : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_r (S 3)).

Theorem unpack_b_u_r_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> set -> prop) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f i R = Phi X f' i' R')
  ->
  forall X, forall f:set -> set -> set, forall i:set -> set, forall R:set -> set -> prop, unpack_b_u_r (pack_b_u_r X f i R) Phi = Phi X f i R.
let Phi.
assume HPhi.
let X f i R.
prove Phi (pack_b_u_r X f i R 0) (decode_b (pack_b_u_r X f i R 1)) (decode_u (pack_b_u_r X f i R 2)) (decode_r (pack_b_u_r X f i R 3)) = Phi X f i R.
rewrite <- struct_b_u_r_0_eq (pack_b_u_r X f i R) X f i R (eqI set (pack_b_u_r X f i R)).
prove Phi X (decode_b (pack_b_u_r X f i R 1)) (decode_u (pack_b_u_r X f i R 2)) (decode_r (pack_b_u_r X f i R 3)) = Phi X f i R.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_u_r X f i R 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_u_r_1_eq (pack_b_u_r X f i R) X f i R (eqI set (pack_b_u_r X f i R)) x Hx y Hy.
- let x. assume Hx.
  prove decode_u (pack_b_u_r X f i R 2) x = i x.
  apply eq_sym set.
  exact struct_b_u_r_2_eq (pack_b_u_r X f i R) X f i R (eqI set (pack_b_u_r X f i R)) x Hx.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_b_u_r X f i R 3) x y <-> R x y.
  rewrite <- struct_b_u_r_3_eq (pack_b_u_r X f i R) X f i R (eqI set (pack_b_u_r X f i R)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_b_u_r.

Definition pack_b_u_p : set -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> set := fun X f i P => (X,encode_b X f,encode_u X i,encode_p X P).

Definition struct_b_u_p : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists i:set -> set, exists P:set -> prop, (forall x y :e X, f x y :e X) /\ (forall x :e X, i x :e X) /\ S = pack_b_u_p X f i P.

Theorem pack_b_u_p_ext : forall X, forall f f':set -> set -> set, forall i i':set -> set, forall P P':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_u_p X f i P = pack_b_u_p X f' i' P'.
let X f f' i i' P P'. assume H1. assume H2. assume H3.
prove (X,encode_b X f,encode_u X i,encode_p X P) = (X,encode_b X f',encode_u X i',encode_p X P').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_b_u_p_0_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, S = pack_b_u_p X f i P -> X = S 0.
let S X f i P. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_u X i,encode_p X P) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_u_p_1_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, S = pack_b_u_p X f i P -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f i P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_u X i,encode_p X P) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_u_p_2_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, S = pack_b_u_p X f i P -> forall x :e X, i x = decode_u (S 2) x.
let S X f i P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_u X i,encode_p X P) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_b_u_p_3_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, S = pack_b_u_p X f i P -> forall x :e X, P x = decode_p (S 3) x.
let S X f i P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_u X i,encode_p X P) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_b_u_p: forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, (forall x y :e X, f x y :e X) -> (forall x :e X, i x :e X) -> struct_b_u_p (pack_b_u_p X f i P).
let X f i P.
assume H1.
assume H2.
prove exists X':set, exists f':set -> set -> set, exists i':set -> set, exists P':set -> prop,  (forall x y :e X', f' x y :e X') /\ (forall x :e X', i' x :e X') /\ pack_b_u_p X f i P = pack_b_u_p X' f' i' P'.
witness X. witness f. witness i. witness P.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_b_u_p_eta: forall S, struct_b_u_p S -> S = pack_b_u_p (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_p (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let i.
assume H3. apply H3. let P.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_u_p_0_eq S X f i P Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_u X (decode_u (S 2)),encode_p X (decode_p (S 3))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_u_p_1_eq S X f i P Heq.
}
rewrite <- L1.
claim L2: encode_u X i = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_b_u_p_2_eq S X f i P Heq.
}
rewrite <- L2.
claim L3: encode_p X P = encode_p X (decode_p (S 3)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_b_u_p_3_eq S X f i P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_u_p.

Variable A:SType.

Definition unpack_b_u_p : set -> (set -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (decode_p (S 3)).

Theorem unpack_b_u_p_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> (set -> prop) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f i P = Phi X f' i' P')
  ->
  forall X, forall f:set -> set -> set, forall i:set -> set, forall P:set -> prop, unpack_b_u_p (pack_b_u_p X f i P) Phi = Phi X f i P.
let Phi.
assume HPhi.
let X f i P.
prove Phi (pack_b_u_p X f i P 0) (decode_b (pack_b_u_p X f i P 1)) (decode_u (pack_b_u_p X f i P 2)) (decode_p (pack_b_u_p X f i P 3)) = Phi X f i P.
rewrite <- struct_b_u_p_0_eq (pack_b_u_p X f i P) X f i P (eqI set (pack_b_u_p X f i P)).
prove Phi X (decode_b (pack_b_u_p X f i P 1)) (decode_u (pack_b_u_p X f i P 2)) (decode_p (pack_b_u_p X f i P 3)) = Phi X f i P.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_u_p X f i P 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_u_p_1_eq (pack_b_u_p X f i P) X f i P (eqI set (pack_b_u_p X f i P)) x Hx y Hy.
- let x. assume Hx.
  prove decode_u (pack_b_u_p X f i P 2) x = i x.
  apply eq_sym set.
  exact struct_b_u_p_2_eq (pack_b_u_p X f i P) X f i P (eqI set (pack_b_u_p X f i P)) x Hx.
- let x. assume Hx.
  prove decode_p (pack_b_u_p X f i P 3) x <-> P x.
  rewrite <- struct_b_u_p_3_eq (pack_b_u_p X f i P) X f i P (eqI set (pack_b_u_p X f i P)) x Hx.
  apply iff_refl.
Qed.

End unpack_b_u_p.

Definition pack_b_u_e : set -> (set -> set -> set) -> (set -> set) -> set -> set := fun X f i c => (X,encode_b X f,encode_u X i,c).

Definition struct_b_u_e : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists i:set -> set, exists c:set, (forall x y :e X, f x y :e X) /\ (forall x :e X, i x :e X) /\ c :e X /\ S = pack_b_u_e X f i c.

Theorem pack_b_u_e_ext : forall X, forall f f':set -> set -> set, forall i i':set -> set, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 pack_b_u_e X f i c = pack_b_u_e X f' i' c.
let X f f' i i' c. assume H1. assume H2.
prove (X,encode_b X f,encode_u X i,c) = (X,encode_b X f',encode_u X i',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_b_u_e_0_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall c:set, S = pack_b_u_e X f i c -> X = S 0.
let S X f i c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_u X i,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_u_e_1_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall c:set, S = pack_b_u_e X f i c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f i c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_u X i,c) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_u_e_2_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall c:set, S = pack_b_u_e X f i c -> forall x :e X, i x = decode_u (S 2) x.
let S X f i c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_u X i,c) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_b_u_e_3_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, forall c:set, S = pack_b_u_e X f i c -> c = S 3.
let S X f i c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_u X i,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_b_u_e: forall X, forall f:set -> set -> set, forall i:set -> set, forall c:set, (forall x y :e X, f x y :e X) -> (forall x :e X, i x :e X) -> c :e X -> struct_b_u_e (pack_b_u_e X f i c).
let X f i c.
assume H1.
assume H2.
assume H3.
prove exists X':set, exists f':set -> set -> set, exists i':set -> set, exists c':set,  (forall x y :e X', f' x y :e X') /\ (forall x :e X', i' x :e X') /\ c' :e X' /\ pack_b_u_e X f i c = pack_b_u_e X' f' i' c'.
witness X. witness f. witness i. witness c.
apply andI.
apply andI.
apply andI.
exact H1.
exact H2.
exact H3.
apply eqI set.
Qed.

Theorem struct_b_u_e_eta: forall S, struct_b_u_e S -> S = pack_b_u_e (S 0) (decode_b (S 1)) (decode_u (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let i.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_u_e_0_eq S X f i c Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_u X (decode_u (S 2)),S 3).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_u_e_1_eq S X f i c Heq.
}
rewrite <- L1.
claim L2: encode_u X i = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_b_u_e_2_eq S X f i c Heq.
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_b_u_e_3_eq S X f i c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_u_e.

Variable A:SType.

Definition unpack_b_u_e : set -> (set -> (set -> set -> set) -> (set -> set) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)) (S 3).

Theorem unpack_b_u_e_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> set -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall c,Phi X f i c = Phi X f' i' c)
  ->
  forall X, forall f:set -> set -> set, forall i:set -> set, forall c:set, unpack_b_u_e (pack_b_u_e X f i c) Phi = Phi X f i c.
let Phi.
assume HPhi.
let X f i c.
prove Phi (pack_b_u_e X f i c 0) (decode_b (pack_b_u_e X f i c 1)) (decode_u (pack_b_u_e X f i c 2)) (pack_b_u_e X f i c 3) = Phi X f i c.
rewrite <- struct_b_u_e_0_eq (pack_b_u_e X f i c) X f i c (eqI set (pack_b_u_e X f i c)).
prove Phi X (decode_b (pack_b_u_e X f i c 1)) (decode_u (pack_b_u_e X f i c 2)) (pack_b_u_e X f i c 3) = Phi X f i c.
rewrite <- struct_b_u_e_3_eq (pack_b_u_e X f i c) X f i c (eqI set (pack_b_u_e X f i c)).
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_u_e X f i c 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_u_e_1_eq (pack_b_u_e X f i c) X f i c (eqI set (pack_b_u_e X f i c)) x Hx y Hy.
- let x. assume Hx.
  prove decode_u (pack_b_u_e X f i c 2) x = i x.
  apply eq_sym set.
  exact struct_b_u_e_2_eq (pack_b_u_e X f i c) X f i c (eqI set (pack_b_u_e X f i c)) x Hx.
Qed.

End unpack_b_u_e.

Definition pack_b_r_p : set -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> set := fun X f R P => (X,encode_b X f,encode_r X R,encode_p X P).

Definition struct_b_r_p : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists R:set -> set -> prop, exists P:set -> prop, (forall x y :e X, f x y :e X) /\ S = pack_b_r_p X f R P.

Theorem pack_b_r_p_ext : forall X, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall P P':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_r_p X f R P = pack_b_r_p X f' R' P'.
let X f f' R R' P P'. assume H1. assume H2. assume H3.
prove (X,encode_b X f,encode_r X R,encode_p X P) = (X,encode_b X f',encode_r X R',encode_p X P').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_b_r_p_0_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_r_p X f R P -> X = S 0.
let S X f R P. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_r X R,encode_p X P) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_r_p_1_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_r_p X f R P -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_r X R,encode_p X P) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_r_p_2_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_r_p X f R P -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X f R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_r X R,encode_p X P) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_b_r_p_3_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_b_r_p X f R P -> forall x :e X, P x = decode_p (S 3) x.
let S X f R P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_r X R,encode_p X P) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_b_r_p: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, (forall x y :e X, f x y :e X) -> struct_b_r_p (pack_b_r_p X f R P).
let X f R P.
assume H1.
prove exists X':set, exists f':set -> set -> set, exists R':set -> set -> prop, exists P':set -> prop,  (forall x y :e X', f' x y :e X') /\ pack_b_r_p X f R P = pack_b_r_p X' f' R' P'.
witness X. witness f. witness R. witness P.
apply andI.
exact H1.
apply eqI set.
Qed.

Theorem struct_b_r_p_eta: forall S, struct_b_r_p S -> S = pack_b_r_p (S 0) (decode_b (S 1)) (decode_r (S 2)) (decode_p (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let R.
assume H3. apply H3. let P.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_r_p_0_eq S X f R P Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_r X (decode_r (S 2)),encode_p X (decode_p (S 3))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_r_p_1_eq S X f R P Heq.
}
rewrite <- L1.
claim L2: encode_r X R = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_b_r_p_2_eq S X f R P Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L2.
claim L3: encode_p X P = encode_p X (decode_p (S 3)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_b_r_p_3_eq S X f R P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_r_p.

Variable A:SType.

Definition unpack_b_r_p : set -> (set -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_r (S 2)) (decode_p (S 3)).

Theorem unpack_b_r_p_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> prop) -> (set -> prop) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f R P = Phi X f' R' P')
  ->
  forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall P:set -> prop, unpack_b_r_p (pack_b_r_p X f R P) Phi = Phi X f R P.
let Phi.
assume HPhi.
let X f R P.
prove Phi (pack_b_r_p X f R P 0) (decode_b (pack_b_r_p X f R P 1)) (decode_r (pack_b_r_p X f R P 2)) (decode_p (pack_b_r_p X f R P 3)) = Phi X f R P.
rewrite <- struct_b_r_p_0_eq (pack_b_r_p X f R P) X f R P (eqI set (pack_b_r_p X f R P)).
prove Phi X (decode_b (pack_b_r_p X f R P 1)) (decode_r (pack_b_r_p X f R P 2)) (decode_p (pack_b_r_p X f R P 3)) = Phi X f R P.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_r_p X f R P 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_r_p_1_eq (pack_b_r_p X f R P) X f R P (eqI set (pack_b_r_p X f R P)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_b_r_p X f R P 2) x y <-> R x y.
  rewrite <- struct_b_r_p_2_eq (pack_b_r_p X f R P) X f R P (eqI set (pack_b_r_p X f R P)) x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove decode_p (pack_b_r_p X f R P 3) x <-> P x.
  rewrite <- struct_b_r_p_3_eq (pack_b_r_p X f R P) X f R P (eqI set (pack_b_r_p X f R P)) x Hx.
  apply iff_refl.
Qed.

End unpack_b_r_p.

Definition pack_b_r_e : set -> (set -> set -> set) -> (set -> set -> prop) -> set -> set := fun X f R c => (X,encode_b X f,encode_r X R,c).

Definition struct_b_r_e : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists R:set -> set -> prop, exists c:set, (forall x y :e X, f x y :e X) /\ c :e X /\ S = pack_b_r_e X f R c.

Theorem pack_b_r_e_ext : forall X, forall f f':set -> set -> set, forall R R':set -> set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_b_r_e X f R c = pack_b_r_e X f' R' c.
let X f f' R R' c. assume H1. assume H2.
prove (X,encode_b X f,encode_r X R,c) = (X,encode_b X f',encode_r X R',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_b_r_e_0_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_r_e X f R c -> X = S 0.
let S X f R c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_r X R,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_r_e_1_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_r_e X f R c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_r X R,c) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_r_e_2_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_r_e X f R c -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X f R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_r X R,c) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_b_r_e_3_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, forall c:set, S = pack_b_r_e X f R c -> c = S 3.
let S X f R c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_r X R,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_b_r_e: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall c:set, (forall x y :e X, f x y :e X) -> c :e X -> struct_b_r_e (pack_b_r_e X f R c).
let X f R c.
assume H1.
assume H3.
prove exists X':set, exists f':set -> set -> set, exists R':set -> set -> prop, exists c':set,  (forall x y :e X', f' x y :e X') /\ c' :e X' /\ pack_b_r_e X f R c = pack_b_r_e X' f' R' c'.
witness X. witness f. witness R. witness c.
apply andI.
apply andI.
exact H1.
exact H3.
apply eqI set.
Qed.

Theorem struct_b_r_e_eta: forall S, struct_b_r_e S -> S = pack_b_r_e (S 0) (decode_b (S 1)) (decode_r (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let R.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_r_e_0_eq S X f R c Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_r X (decode_r (S 2)),S 3).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_r_e_1_eq S X f R c Heq.
}
rewrite <- L1.
claim L2: encode_r X R = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_b_r_e_2_eq S X f R c Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_b_r_e_3_eq S X f R c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_r_e.

Variable A:SType.

Definition unpack_b_r_e : set -> (set -> (set -> set -> set) -> (set -> set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_r (S 2)) (S 3).

Theorem unpack_b_r_e_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> prop) -> set -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall c,Phi X f R c = Phi X f' R' c)
  ->
  forall X, forall f:set -> set -> set, forall R:set -> set -> prop, forall c:set, unpack_b_r_e (pack_b_r_e X f R c) Phi = Phi X f R c.
let Phi.
assume HPhi.
let X f R c.
prove Phi (pack_b_r_e X f R c 0) (decode_b (pack_b_r_e X f R c 1)) (decode_r (pack_b_r_e X f R c 2)) (pack_b_r_e X f R c 3) = Phi X f R c.
rewrite <- struct_b_r_e_0_eq (pack_b_r_e X f R c) X f R c (eqI set (pack_b_r_e X f R c)).
prove Phi X (decode_b (pack_b_r_e X f R c 1)) (decode_r (pack_b_r_e X f R c 2)) (pack_b_r_e X f R c 3) = Phi X f R c.
rewrite <- struct_b_r_e_3_eq (pack_b_r_e X f R c) X f R c (eqI set (pack_b_r_e X f R c)).
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_r_e X f R c 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_r_e_1_eq (pack_b_r_e X f R c) X f R c (eqI set (pack_b_r_e X f R c)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_b_r_e X f R c 2) x y <-> R x y.
  rewrite <- struct_b_r_e_2_eq (pack_b_r_e X f R c) X f R c (eqI set (pack_b_r_e X f R c)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_b_r_e.

Definition pack_b_p_e : set -> (set -> set -> set) -> (set -> prop) -> set -> set := fun X f P c => (X,encode_b X f,encode_p X P,c).

Definition struct_b_p_e : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists P:set -> prop, exists c:set, (forall x y :e X, f x y :e X) /\ c :e X /\ S = pack_b_p_e X f P c.

Theorem pack_b_p_e_ext : forall X, forall f f':set -> set -> set, forall P P':set -> prop, forall c,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_p_e X f P c = pack_b_p_e X f' P' c.
let X f f' P P' c. assume H1. assume H2.
prove (X,encode_b X f,encode_p X P,c) = (X,encode_b X f',encode_p X P',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_b_p_e_0_eq: forall S X, forall f:set -> set -> set, forall P:set -> prop, forall c:set, S = pack_b_p_e X f P c -> X = S 0.
let S X f P c. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_p X P,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_b_p_e_1_eq: forall S X, forall f:set -> set -> set, forall P:set -> prop, forall c:set, S = pack_b_p_e X f P c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_p X P,c) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_p_e_2_eq: forall S X, forall f:set -> set -> set, forall P:set -> prop, forall c:set, S = pack_b_p_e X f P c -> forall x :e X, P x = decode_p (S 2) x.
let S X f P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_p X P,c) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem struct_b_p_e_3_eq: forall S X, forall f:set -> set -> set, forall P:set -> prop, forall c:set, S = pack_b_p_e X f P c -> c = S 3.
let S X f P c. assume H1.
rewrite H1. prove c = (X,encode_b X f,encode_p X P,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_b_p_e: forall X, forall f:set -> set -> set, forall P:set -> prop, forall c:set, (forall x y :e X, f x y :e X) -> c :e X -> struct_b_p_e (pack_b_p_e X f P c).
let X f P c.
assume H1.
assume H3.
prove exists X':set, exists f':set -> set -> set, exists P':set -> prop, exists c':set,  (forall x y :e X', f' x y :e X') /\ c' :e X' /\ pack_b_p_e X f P c = pack_b_p_e X' f' P' c'.
witness X. witness f. witness P. witness c.
apply andI.
apply andI.
exact H1.
exact H3.
apply eqI set.
Qed.

Theorem struct_b_p_e_eta: forall S, struct_b_p_e S -> S = pack_b_p_e (S 0) (decode_b (S 1)) (decode_p (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let P.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_p_e_0_eq S X f P c Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_p X (decode_p (S 2)),S 3).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_p_e_1_eq S X f P c Heq.
}
rewrite <- L1.
claim L2: encode_p X P = encode_p X (decode_p (S 2)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_b_p_e_2_eq S X f P c Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_b_p_e_3_eq S X f P c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_b_p_e.

Variable A:SType.

Definition unpack_b_p_e : set -> (set -> (set -> set -> set) -> (set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_p (S 2)) (S 3).

Theorem unpack_b_p_e_eq : forall Phi:set -> (set -> set -> set) -> (set -> prop) -> set -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall c,Phi X f P c = Phi X f' P' c)
  ->
  forall X, forall f:set -> set -> set, forall P:set -> prop, forall c:set, unpack_b_p_e (pack_b_p_e X f P c) Phi = Phi X f P c.
let Phi.
assume HPhi.
let X f P c.
prove Phi (pack_b_p_e X f P c 0) (decode_b (pack_b_p_e X f P c 1)) (decode_p (pack_b_p_e X f P c 2)) (pack_b_p_e X f P c 3) = Phi X f P c.
rewrite <- struct_b_p_e_0_eq (pack_b_p_e X f P c) X f P c (eqI set (pack_b_p_e X f P c)).
prove Phi X (decode_b (pack_b_p_e X f P c 1)) (decode_p (pack_b_p_e X f P c 2)) (pack_b_p_e X f P c 3) = Phi X f P c.
rewrite <- struct_b_p_e_3_eq (pack_b_p_e X f P c) X f P c (eqI set (pack_b_p_e X f P c)).
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_p_e X f P c 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_p_e_1_eq (pack_b_p_e X f P c) X f P c (eqI set (pack_b_p_e X f P c)) x Hx y Hy.
- let x. assume Hx.
  prove decode_p (pack_b_p_e X f P c 2) x <-> P x.
  rewrite <- struct_b_p_e_2_eq (pack_b_p_e X f P c) X f P c (eqI set (pack_b_p_e X f P c)) x Hx.
  apply iff_refl.
Qed.

End unpack_b_p_e.

Definition pack_u_u_r : set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> set := fun X i j R => (X,encode_u X i,encode_u X j,encode_r X R).

Definition struct_u_u_r : set -> prop := fun S => exists X:set, exists i:set -> set, exists j:set -> set, exists R:set -> set -> prop, (forall x :e X, i x :e X) /\ (forall x :e X, j x :e X) /\ S = pack_u_u_r X i j R.

Theorem pack_u_u_r_ext : forall X, forall i i':set -> set, forall j j':set -> set, forall R R':set -> set -> prop,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_u_u_r X i j R = pack_u_u_r X i' j' R'.
let X i i' j j' R R'. assume H1. assume H2. assume H3.
prove (X,encode_u X i,encode_u X j,encode_r X R) = (X,encode_u X i',encode_u X j',encode_r X R').
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_u_u_r_0_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_u_u_r X i j R -> X = S 0.
let S X i j R. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_u X j,encode_r X R) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_u_u_r_1_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_u_u_r X i j R -> forall x :e X, i x = decode_u (S 1) x.
let S X i j R. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R) 1) x.
rewrite tuple_4_1_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_u_u_r_2_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_u_u_r X i j R -> forall x :e X, j x = decode_u (S 2) x.
let S X i j R. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_u X i,encode_u X j,encode_r X R) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym set. apply decode_encode_u X j x Hx.
Qed.

Theorem struct_u_u_r_3_eq: forall S X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, S = pack_u_u_r X i j R -> forall x y :e X, R x y = decode_r (S 3) x y.
let S X i j R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_u X i,encode_u X j,encode_r X R) 3) x y.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_struct_u_u_r: forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, (forall x :e X, i x :e X) -> (forall x :e X, j x :e X) -> struct_u_u_r (pack_u_u_r X i j R).
let X i j R.
assume H1.
assume H2.
prove exists X':set, exists i':set -> set, exists j':set -> set, exists R':set -> set -> prop,  (forall x :e X', i' x :e X') /\ (forall x :e X', j' x :e X') /\ pack_u_u_r X i j R = pack_u_u_r X' i' j' R'.
witness X. witness i. witness j. witness R.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_u_u_r_eta: forall S, struct_u_u_r S -> S = pack_u_u_r (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let i.
assume H2. apply H2. let j.
assume H3. apply H3. let R.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_u_u_r_0_eq S X i j R Heq.
prove S = (X,encode_u X (decode_u (S 1)),encode_u X (decode_u (S 2)),encode_r X (decode_r (S 3))).
claim L1: encode_u X i = encode_u X (decode_u (S 1)).
{ apply encode_u_ext.
  exact struct_u_u_r_1_eq S X i j R Heq.
}
rewrite <- L1.
claim L2: encode_u X j = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_u_u_r_2_eq S X i j R Heq.
}
rewrite <- L2.
claim L3: encode_r X R = encode_r X (decode_r (S 3)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_u_u_r_3_eq S X i j R Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_u_u_r.

Variable A:SType.

Definition unpack_u_u_r : set -> (set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_r (S 3)).

Theorem unpack_u_u_r_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> set -> prop) -> A,
  (forall X, forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall j j':set -> set, (forall x :e X, j x = j' x) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X i j R = Phi X i' j' R')
  ->
  forall X, forall i:set -> set, forall j:set -> set, forall R:set -> set -> prop, unpack_u_u_r (pack_u_u_r X i j R) Phi = Phi X i j R.
let Phi.
assume HPhi.
let X i j R.
prove Phi (pack_u_u_r X i j R 0) (decode_u (pack_u_u_r X i j R 1)) (decode_u (pack_u_u_r X i j R 2)) (decode_r (pack_u_u_r X i j R 3)) = Phi X i j R.
rewrite <- struct_u_u_r_0_eq (pack_u_u_r X i j R) X i j R (eqI set (pack_u_u_r X i j R)).
prove Phi X (decode_u (pack_u_u_r X i j R 1)) (decode_u (pack_u_u_r X i j R 2)) (decode_r (pack_u_u_r X i j R 3)) = Phi X i j R.
apply HPhi.
- let x. assume Hx.
  prove decode_u (pack_u_u_r X i j R 1) x = i x.
  apply eq_sym set.
  exact struct_u_u_r_1_eq (pack_u_u_r X i j R) X i j R (eqI set (pack_u_u_r X i j R)) x Hx.
- let x. assume Hx.
  prove decode_u (pack_u_u_r X i j R 2) x = j x.
  apply eq_sym set.
  exact struct_u_u_r_2_eq (pack_u_u_r X i j R) X i j R (eqI set (pack_u_u_r X i j R)) x Hx.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_u_u_r X i j R 3) x y <-> R x y.
  rewrite <- struct_u_u_r_3_eq (pack_u_u_r X i j R) X i j R (eqI set (pack_u_u_r X i j R)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_u_u_r.

Definition pack_u_u_p : set -> (set -> set) -> (set -> set) -> (set -> prop) -> set := fun X i j P => (X,encode_u X i,encode_u X j,encode_p X P).

Definition struct_u_u_p : set -> prop := fun S => exists X:set, exists i:set -> set, exists j:set -> set, exists P:set -> prop, (forall x :e X, i x :e X) /\ (forall x :e X, j x :e X) /\ S = pack_u_u_p X i j P.

Theorem pack_u_u_p_ext : forall X, forall i i':set -> set, forall j j':set -> set, forall P P':set -> prop,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_u_u_p X i j P = pack_u_u_p X i' j' P'.
let X i i' j j' P P'. assume H1. assume H2. assume H3.
prove (X,encode_u X i,encode_u X j,encode_p X P) = (X,encode_u X i',encode_u X j',encode_p X P').
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_u_u_p_0_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_u_u_p X i j P -> X = S 0.
let S X i j P. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_u X j,encode_p X P) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_u_u_p_1_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_u_u_p X i j P -> forall x :e X, i x = decode_u (S 1) x.
let S X i j P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_u X j,encode_p X P) 1) x.
rewrite tuple_4_1_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_u_u_p_2_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_u_u_p X i j P -> forall x :e X, j x = decode_u (S 2) x.
let S X i j P. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_u X i,encode_u X j,encode_p X P) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym set. apply decode_encode_u X j x Hx.
Qed.

Theorem struct_u_u_p_3_eq: forall S X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, S = pack_u_u_p X i j P -> forall x :e X, P x = decode_p (S 3) x.
let S X i j P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_u X i,encode_u X j,encode_p X P) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_u_u_p: forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, (forall x :e X, i x :e X) -> (forall x :e X, j x :e X) -> struct_u_u_p (pack_u_u_p X i j P).
let X i j P.
assume H1.
assume H2.
prove exists X':set, exists i':set -> set, exists j':set -> set, exists P':set -> prop,  (forall x :e X', i' x :e X') /\ (forall x :e X', j' x :e X') /\ pack_u_u_p X i j P = pack_u_u_p X' i' j' P'.
witness X. witness i. witness j. witness P.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_u_u_p_eta: forall S, struct_u_u_p S -> S = pack_u_u_p (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_p (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let i.
assume H2. apply H2. let j.
assume H3. apply H3. let P.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_u_u_p_0_eq S X i j P Heq.
prove S = (X,encode_u X (decode_u (S 1)),encode_u X (decode_u (S 2)),encode_p X (decode_p (S 3))).
claim L1: encode_u X i = encode_u X (decode_u (S 1)).
{ apply encode_u_ext.
  exact struct_u_u_p_1_eq S X i j P Heq.
}
rewrite <- L1.
claim L2: encode_u X j = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_u_u_p_2_eq S X i j P Heq.
}
rewrite <- L2.
claim L3: encode_p X P = encode_p X (decode_p (S 3)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_u_u_p_3_eq S X i j P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_u_u_p.

Variable A:SType.

Definition unpack_u_u_p : set -> (set -> (set -> set) -> (set -> set) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (decode_p (S 3)).

Theorem unpack_u_u_p_eq : forall Phi:set -> (set -> set) -> (set -> set) -> (set -> prop) -> A,
  (forall X, forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall j j':set -> set, (forall x :e X, j x = j' x) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X i j P = Phi X i' j' P')
  ->
  forall X, forall i:set -> set, forall j:set -> set, forall P:set -> prop, unpack_u_u_p (pack_u_u_p X i j P) Phi = Phi X i j P.
let Phi.
assume HPhi.
let X i j P.
prove Phi (pack_u_u_p X i j P 0) (decode_u (pack_u_u_p X i j P 1)) (decode_u (pack_u_u_p X i j P 2)) (decode_p (pack_u_u_p X i j P 3)) = Phi X i j P.
rewrite <- struct_u_u_p_0_eq (pack_u_u_p X i j P) X i j P (eqI set (pack_u_u_p X i j P)).
prove Phi X (decode_u (pack_u_u_p X i j P 1)) (decode_u (pack_u_u_p X i j P 2)) (decode_p (pack_u_u_p X i j P 3)) = Phi X i j P.
apply HPhi.
- let x. assume Hx.
  prove decode_u (pack_u_u_p X i j P 1) x = i x.
  apply eq_sym set.
  exact struct_u_u_p_1_eq (pack_u_u_p X i j P) X i j P (eqI set (pack_u_u_p X i j P)) x Hx.
- let x. assume Hx.
  prove decode_u (pack_u_u_p X i j P 2) x = j x.
  apply eq_sym set.
  exact struct_u_u_p_2_eq (pack_u_u_p X i j P) X i j P (eqI set (pack_u_u_p X i j P)) x Hx.
- let x. assume Hx.
  prove decode_p (pack_u_u_p X i j P 3) x <-> P x.
  rewrite <- struct_u_u_p_3_eq (pack_u_u_p X i j P) X i j P (eqI set (pack_u_u_p X i j P)) x Hx.
  apply iff_refl.
Qed.

End unpack_u_u_p.

Definition pack_u_u_e : set -> (set -> set) -> (set -> set) -> set -> set := fun X i j c => (X,encode_u X i,encode_u X j,c).

Definition struct_u_u_e : set -> prop := fun S => exists X:set, exists i:set -> set, exists j:set -> set, exists c:set, (forall x :e X, i x :e X) /\ (forall x :e X, j x :e X) /\ c :e X /\ S = pack_u_u_e X i j c.

Theorem pack_u_u_e_ext : forall X, forall i i':set -> set, forall j j':set -> set, forall c,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 pack_u_u_e X i j c = pack_u_u_e X i' j' c.
let X i i' j j' c. assume H1. assume H2.
prove (X,encode_u X i,encode_u X j,c) = (X,encode_u X i',encode_u X j',c).
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_u_u_e_0_eq: forall S X, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_u_u_e X i j c -> X = S 0.
let S X i j c. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_u X j,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_u_u_e_1_eq: forall S X, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_u_u_e X i j c -> forall x :e X, i x = decode_u (S 1) x.
let S X i j c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_u X j,c) 1) x.
rewrite tuple_4_1_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_u_u_e_2_eq: forall S X, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_u_u_e X i j c -> forall x :e X, j x = decode_u (S 2) x.
let S X i j c. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_u X i,encode_u X j,c) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym set. apply decode_encode_u X j x Hx.
Qed.

Theorem struct_u_u_e_3_eq: forall S X, forall i:set -> set, forall j:set -> set, forall c:set, S = pack_u_u_e X i j c -> c = S 3.
let S X i j c. assume H1.
rewrite H1. prove c = (X,encode_u X i,encode_u X j,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_u_u_e: forall X, forall i:set -> set, forall j:set -> set, forall c:set, (forall x :e X, i x :e X) -> (forall x :e X, j x :e X) -> c :e X -> struct_u_u_e (pack_u_u_e X i j c).
let X i j c.
assume H1.
assume H2.
assume H3.
prove exists X':set, exists i':set -> set, exists j':set -> set, exists c':set,  (forall x :e X', i' x :e X') /\ (forall x :e X', j' x :e X') /\ c' :e X' /\ pack_u_u_e X i j c = pack_u_u_e X' i' j' c'.
witness X. witness i. witness j. witness c.
apply andI.
apply andI.
apply andI.
exact H1.
exact H2.
exact H3.
apply eqI set.
Qed.

Theorem struct_u_u_e_eta: forall S, struct_u_u_e S -> S = pack_u_u_e (S 0) (decode_u (S 1)) (decode_u (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let i.
assume H2. apply H2. let j.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_u_u_e_0_eq S X i j c Heq.
prove S = (X,encode_u X (decode_u (S 1)),encode_u X (decode_u (S 2)),S 3).
claim L1: encode_u X i = encode_u X (decode_u (S 1)).
{ apply encode_u_ext.
  exact struct_u_u_e_1_eq S X i j c Heq.
}
rewrite <- L1.
claim L2: encode_u X j = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_u_u_e_2_eq S X i j c Heq.
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_u_u_e_3_eq S X i j c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_u_u_e.

Variable A:SType.

Definition unpack_u_u_e : set -> (set -> (set -> set) -> (set -> set) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)) (S 3).

Theorem unpack_u_u_e_eq : forall Phi:set -> (set -> set) -> (set -> set) -> set -> A,
  (forall X, forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall j j':set -> set, (forall x :e X, j x = j' x) ->  forall c,Phi X i j c = Phi X i' j' c)
  ->
  forall X, forall i:set -> set, forall j:set -> set, forall c:set, unpack_u_u_e (pack_u_u_e X i j c) Phi = Phi X i j c.
let Phi.
assume HPhi.
let X i j c.
prove Phi (pack_u_u_e X i j c 0) (decode_u (pack_u_u_e X i j c 1)) (decode_u (pack_u_u_e X i j c 2)) (pack_u_u_e X i j c 3) = Phi X i j c.
rewrite <- struct_u_u_e_0_eq (pack_u_u_e X i j c) X i j c (eqI set (pack_u_u_e X i j c)).
prove Phi X (decode_u (pack_u_u_e X i j c 1)) (decode_u (pack_u_u_e X i j c 2)) (pack_u_u_e X i j c 3) = Phi X i j c.
rewrite <- struct_u_u_e_3_eq (pack_u_u_e X i j c) X i j c (eqI set (pack_u_u_e X i j c)).
apply HPhi.
- let x. assume Hx.
  prove decode_u (pack_u_u_e X i j c 1) x = i x.
  apply eq_sym set.
  exact struct_u_u_e_1_eq (pack_u_u_e X i j c) X i j c (eqI set (pack_u_u_e X i j c)) x Hx.
- let x. assume Hx.
  prove decode_u (pack_u_u_e X i j c 2) x = j x.
  apply eq_sym set.
  exact struct_u_u_e_2_eq (pack_u_u_e X i j c) X i j c (eqI set (pack_u_u_e X i j c)) x Hx.
Qed.

End unpack_u_u_e.

Definition pack_u_r_p : set -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> set := fun X i R P => (X,encode_u X i,encode_r X R,encode_p X P).

Definition struct_u_r_p : set -> prop := fun S => exists X:set, exists i:set -> set, exists R:set -> set -> prop, exists P:set -> prop, (forall x :e X, i x :e X) /\ S = pack_u_r_p X i R P.

Theorem pack_u_r_p_ext : forall X, forall i i':set -> set, forall R R':set -> set -> prop, forall P P':set -> prop,
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_u_r_p X i R P = pack_u_r_p X i' R' P'.
let X i i' R R' P P'. assume H1. assume H2. assume H3.
prove (X,encode_u X i,encode_r X R,encode_p X P) = (X,encode_u X i',encode_r X R',encode_p X P').
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_u_r_p_0_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_u_r_p X i R P -> X = S 0.
let S X i R P. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_r X R,encode_p X P) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_u_r_p_1_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_u_r_p X i R P -> forall x :e X, i x = decode_u (S 1) x.
let S X i R P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_r X R,encode_p X P) 1) x.
rewrite tuple_4_1_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_u_r_p_2_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_u_r_p X i R P -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X i R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_u X i,encode_r X R,encode_p X P) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_u_r_p_3_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, S = pack_u_r_p X i R P -> forall x :e X, P x = decode_p (S 3) x.
let S X i R P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_u X i,encode_r X R,encode_p X P) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_u_r_p: forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, (forall x :e X, i x :e X) -> struct_u_r_p (pack_u_r_p X i R P).
let X i R P.
assume H1.
prove exists X':set, exists i':set -> set, exists R':set -> set -> prop, exists P':set -> prop,  (forall x :e X', i' x :e X') /\ pack_u_r_p X i R P = pack_u_r_p X' i' R' P'.
witness X. witness i. witness R. witness P.
apply andI.
exact H1.
apply eqI set.
Qed.

Theorem struct_u_r_p_eta: forall S, struct_u_r_p S -> S = pack_u_r_p (S 0) (decode_u (S 1)) (decode_r (S 2)) (decode_p (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let i.
assume H2. apply H2. let R.
assume H3. apply H3. let P.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_u_r_p_0_eq S X i R P Heq.
prove S = (X,encode_u X (decode_u (S 1)),encode_r X (decode_r (S 2)),encode_p X (decode_p (S 3))).
claim L1: encode_u X i = encode_u X (decode_u (S 1)).
{ apply encode_u_ext.
  exact struct_u_r_p_1_eq S X i R P Heq.
}
rewrite <- L1.
claim L2: encode_r X R = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_u_r_p_2_eq S X i R P Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L2.
claim L3: encode_p X P = encode_p X (decode_p (S 3)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_u_r_p_3_eq S X i R P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_u_r_p.

Variable A:SType.

Definition unpack_u_r_p : set -> (set -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_r (S 2)) (decode_p (S 3)).

Theorem unpack_u_r_p_eq : forall Phi:set -> (set -> set) -> (set -> set -> prop) -> (set -> prop) -> A,
  (forall X, forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X i R P = Phi X i' R' P')
  ->
  forall X, forall i:set -> set, forall R:set -> set -> prop, forall P:set -> prop, unpack_u_r_p (pack_u_r_p X i R P) Phi = Phi X i R P.
let Phi.
assume HPhi.
let X i R P.
prove Phi (pack_u_r_p X i R P 0) (decode_u (pack_u_r_p X i R P 1)) (decode_r (pack_u_r_p X i R P 2)) (decode_p (pack_u_r_p X i R P 3)) = Phi X i R P.
rewrite <- struct_u_r_p_0_eq (pack_u_r_p X i R P) X i R P (eqI set (pack_u_r_p X i R P)).
prove Phi X (decode_u (pack_u_r_p X i R P 1)) (decode_r (pack_u_r_p X i R P 2)) (decode_p (pack_u_r_p X i R P 3)) = Phi X i R P.
apply HPhi.
- let x. assume Hx.
  prove decode_u (pack_u_r_p X i R P 1) x = i x.
  apply eq_sym set.
  exact struct_u_r_p_1_eq (pack_u_r_p X i R P) X i R P (eqI set (pack_u_r_p X i R P)) x Hx.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_u_r_p X i R P 2) x y <-> R x y.
  rewrite <- struct_u_r_p_2_eq (pack_u_r_p X i R P) X i R P (eqI set (pack_u_r_p X i R P)) x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove decode_p (pack_u_r_p X i R P 3) x <-> P x.
  rewrite <- struct_u_r_p_3_eq (pack_u_r_p X i R P) X i R P (eqI set (pack_u_r_p X i R P)) x Hx.
  apply iff_refl.
Qed.

End unpack_u_r_p.

Definition pack_u_r_e : set -> (set -> set) -> (set -> set -> prop) -> set -> set := fun X i R c => (X,encode_u X i,encode_r X R,c).

Definition struct_u_r_e : set -> prop := fun S => exists X:set, exists i:set -> set, exists R:set -> set -> prop, exists c:set, (forall x :e X, i x :e X) /\ c :e X /\ S = pack_u_r_e X i R c.

Theorem pack_u_r_e_ext : forall X, forall i i':set -> set, forall R R':set -> set -> prop, forall c,
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_u_r_e X i R c = pack_u_r_e X i' R' c.
let X i i' R R' c. assume H1. assume H2.
prove (X,encode_u X i,encode_r X R,c) = (X,encode_u X i',encode_r X R',c).
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_u_r_e_0_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_u_r_e X i R c -> X = S 0.
let S X i R c. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_r X R,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_u_r_e_1_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_u_r_e X i R c -> forall x :e X, i x = decode_u (S 1) x.
let S X i R c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_r X R,c) 1) x.
rewrite tuple_4_1_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_u_r_e_2_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_u_r_e X i R c -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X i R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_u X i,encode_r X R,c) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_u_r_e_3_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, forall c:set, S = pack_u_r_e X i R c -> c = S 3.
let S X i R c. assume H1.
rewrite H1. prove c = (X,encode_u X i,encode_r X R,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_u_r_e: forall X, forall i:set -> set, forall R:set -> set -> prop, forall c:set, (forall x :e X, i x :e X) -> c :e X -> struct_u_r_e (pack_u_r_e X i R c).
let X i R c.
assume H1.
assume H3.
prove exists X':set, exists i':set -> set, exists R':set -> set -> prop, exists c':set,  (forall x :e X', i' x :e X') /\ c' :e X' /\ pack_u_r_e X i R c = pack_u_r_e X' i' R' c'.
witness X. witness i. witness R. witness c.
apply andI.
apply andI.
exact H1.
exact H3.
apply eqI set.
Qed.

Theorem struct_u_r_e_eta: forall S, struct_u_r_e S -> S = pack_u_r_e (S 0) (decode_u (S 1)) (decode_r (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let i.
assume H2. apply H2. let R.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_u_r_e_0_eq S X i R c Heq.
prove S = (X,encode_u X (decode_u (S 1)),encode_r X (decode_r (S 2)),S 3).
claim L1: encode_u X i = encode_u X (decode_u (S 1)).
{ apply encode_u_ext.
  exact struct_u_r_e_1_eq S X i R c Heq.
}
rewrite <- L1.
claim L2: encode_r X R = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_u_r_e_2_eq S X i R c Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_u_r_e_3_eq S X i R c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_u_r_e.

Variable A:SType.

Definition unpack_u_r_e : set -> (set -> (set -> set) -> (set -> set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_r (S 2)) (S 3).

Theorem unpack_u_r_e_eq : forall Phi:set -> (set -> set) -> (set -> set -> prop) -> set -> A,
  (forall X, forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall c,Phi X i R c = Phi X i' R' c)
  ->
  forall X, forall i:set -> set, forall R:set -> set -> prop, forall c:set, unpack_u_r_e (pack_u_r_e X i R c) Phi = Phi X i R c.
let Phi.
assume HPhi.
let X i R c.
prove Phi (pack_u_r_e X i R c 0) (decode_u (pack_u_r_e X i R c 1)) (decode_r (pack_u_r_e X i R c 2)) (pack_u_r_e X i R c 3) = Phi X i R c.
rewrite <- struct_u_r_e_0_eq (pack_u_r_e X i R c) X i R c (eqI set (pack_u_r_e X i R c)).
prove Phi X (decode_u (pack_u_r_e X i R c 1)) (decode_r (pack_u_r_e X i R c 2)) (pack_u_r_e X i R c 3) = Phi X i R c.
rewrite <- struct_u_r_e_3_eq (pack_u_r_e X i R c) X i R c (eqI set (pack_u_r_e X i R c)).
apply HPhi.
- let x. assume Hx.
  prove decode_u (pack_u_r_e X i R c 1) x = i x.
  apply eq_sym set.
  exact struct_u_r_e_1_eq (pack_u_r_e X i R c) X i R c (eqI set (pack_u_r_e X i R c)) x Hx.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_u_r_e X i R c 2) x y <-> R x y.
  rewrite <- struct_u_r_e_2_eq (pack_u_r_e X i R c) X i R c (eqI set (pack_u_r_e X i R c)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_u_r_e.

Definition pack_u_p_e : set -> (set -> set) -> (set -> prop) -> set -> set := fun X i P c => (X,encode_u X i,encode_p X P,c).

Definition struct_u_p_e : set -> prop := fun S => exists X:set, exists i:set -> set, exists P:set -> prop, exists c:set, (forall x :e X, i x :e X) /\ c :e X /\ S = pack_u_p_e X i P c.

Theorem pack_u_p_e_ext : forall X, forall i i':set -> set, forall P P':set -> prop, forall c,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_u_p_e X i P c = pack_u_p_e X i' P' c.
let X i i' P P' c. assume H1. assume H2.
prove (X,encode_u X i,encode_p X P,c) = (X,encode_u X i',encode_p X P',c).
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_u_p_e_0_eq: forall S X, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_u_p_e X i P c -> X = S 0.
let S X i P c. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_p X P,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_u_p_e_1_eq: forall S X, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_u_p_e X i P c -> forall x :e X, i x = decode_u (S 1) x.
let S X i P c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_p X P,c) 1) x.
rewrite tuple_4_1_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_u_p_e_2_eq: forall S X, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_u_p_e X i P c -> forall x :e X, P x = decode_p (S 2) x.
let S X i P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_u X i,encode_p X P,c) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem struct_u_p_e_3_eq: forall S X, forall i:set -> set, forall P:set -> prop, forall c:set, S = pack_u_p_e X i P c -> c = S 3.
let S X i P c. assume H1.
rewrite H1. prove c = (X,encode_u X i,encode_p X P,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_u_p_e: forall X, forall i:set -> set, forall P:set -> prop, forall c:set, (forall x :e X, i x :e X) -> c :e X -> struct_u_p_e (pack_u_p_e X i P c).
let X i P c.
assume H1.
assume H3.
prove exists X':set, exists i':set -> set, exists P':set -> prop, exists c':set,  (forall x :e X', i' x :e X') /\ c' :e X' /\ pack_u_p_e X i P c = pack_u_p_e X' i' P' c'.
witness X. witness i. witness P. witness c.
apply andI.
apply andI.
exact H1.
exact H3.
apply eqI set.
Qed.

Theorem struct_u_p_e_eta: forall S, struct_u_p_e S -> S = pack_u_p_e (S 0) (decode_u (S 1)) (decode_p (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let i.
assume H2. apply H2. let P.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_u_p_e_0_eq S X i P c Heq.
prove S = (X,encode_u X (decode_u (S 1)),encode_p X (decode_p (S 2)),S 3).
claim L1: encode_u X i = encode_u X (decode_u (S 1)).
{ apply encode_u_ext.
  exact struct_u_p_e_1_eq S X i P c Heq.
}
rewrite <- L1.
claim L2: encode_p X P = encode_p X (decode_p (S 2)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_u_p_e_2_eq S X i P c Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_u_p_e_3_eq S X i P c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_u_p_e.

Variable A:SType.

Definition unpack_u_p_e : set -> (set -> (set -> set) -> (set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_p (S 2)) (S 3).

Theorem unpack_u_p_e_eq : forall Phi:set -> (set -> set) -> (set -> prop) -> set -> A,
  (forall X, forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall c,Phi X i P c = Phi X i' P' c)
  ->
  forall X, forall i:set -> set, forall P:set -> prop, forall c:set, unpack_u_p_e (pack_u_p_e X i P c) Phi = Phi X i P c.
let Phi.
assume HPhi.
let X i P c.
prove Phi (pack_u_p_e X i P c 0) (decode_u (pack_u_p_e X i P c 1)) (decode_p (pack_u_p_e X i P c 2)) (pack_u_p_e X i P c 3) = Phi X i P c.
rewrite <- struct_u_p_e_0_eq (pack_u_p_e X i P c) X i P c (eqI set (pack_u_p_e X i P c)).
prove Phi X (decode_u (pack_u_p_e X i P c 1)) (decode_p (pack_u_p_e X i P c 2)) (pack_u_p_e X i P c 3) = Phi X i P c.
rewrite <- struct_u_p_e_3_eq (pack_u_p_e X i P c) X i P c (eqI set (pack_u_p_e X i P c)).
apply HPhi.
- let x. assume Hx.
  prove decode_u (pack_u_p_e X i P c 1) x = i x.
  apply eq_sym set.
  exact struct_u_p_e_1_eq (pack_u_p_e X i P c) X i P c (eqI set (pack_u_p_e X i P c)) x Hx.
- let x. assume Hx.
  prove decode_p (pack_u_p_e X i P c 2) x <-> P x.
  rewrite <- struct_u_p_e_2_eq (pack_u_p_e X i P c) X i P c (eqI set (pack_u_p_e X i P c)) x Hx.
  apply iff_refl.
Qed.

End unpack_u_p_e.

Definition pack_r_r_p : set -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> set := fun X R T P => (X,encode_r X R,encode_r X T,encode_p X P).

Definition struct_r_r_p : set -> prop := fun S => exists X:set, exists R:set -> set -> prop, exists T:set -> set -> prop, exists P:set -> prop, S = pack_r_r_p X R T P.

Theorem pack_r_r_p_ext : forall X, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall P P':set -> prop,
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_r_r_p X R T P = pack_r_r_p X R' T' P'.
let X R R' T T' P P'. assume H1. assume H2. assume H3.
prove (X,encode_r X R,encode_r X T,encode_p X P) = (X,encode_r X R',encode_r X T',encode_p X P').
claim L1: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
claim L3: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H3. }
rewrite <- L3.
apply eqI set.
Qed.

Theorem struct_r_r_p_0_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_r_r_p X R T P -> X = S 0.
let S X R T P. assume H1. rewrite H1.
prove X = (X,encode_r X R,encode_r X T,encode_p X P) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_r_r_p_1_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_r_r_p X R T P -> forall x y :e X, R x y = decode_r (S 1) x y.
let S X R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_r X R,encode_r X T,encode_p X P) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_r_r_p_2_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_r_r_p X R T P -> forall x y :e X, T x y = decode_r (S 2) x y.
let S X R T P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_r X R,encode_r X T,encode_p X P) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem struct_r_r_p_3_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, S = pack_r_r_p X R T P -> forall x :e X, P x = decode_p (S 3) x.
let S X R T P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_r X R,encode_r X T,encode_p X P) 3) x.
rewrite tuple_4_3_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_r_r_p: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, struct_r_r_p (pack_r_r_p X R T P).
let X R T P.
prove exists X':set, exists R':set -> set -> prop, exists T':set -> set -> prop, exists P':set -> prop,  pack_r_r_p X R T P = pack_r_r_p X' R' T' P'.
witness X. witness R. witness T. witness P.
apply eqI set.
Qed.

Theorem struct_r_r_p_eta: forall S, struct_r_r_p S -> S = pack_r_r_p (S 0) (decode_r (S 1)) (decode_r (S 2)) (decode_p (S 3)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let R.
assume H2. apply H2. let T.
assume H3. apply H3. let P.
assume Heq.
rewrite <- struct_r_r_p_0_eq S X R T P Heq.
prove S = (X,encode_r X (decode_r (S 1)),encode_r X (decode_r (S 2)),encode_p X (decode_p (S 3))).
claim L1: encode_r X R = encode_r X (decode_r (S 1)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_r_r_p_1_eq S X R T P Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L1.
claim L2: encode_r X T = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_r_r_p_2_eq S X R T P Heq x Hx y Hy.
  exact iff_refl (T x y).
}
rewrite <- L2.
claim L3: encode_p X P = encode_p X (decode_p (S 3)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_r_r_p_3_eq S X R T P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L3.
exact Heq.
Qed.

Section unpack_r_r_p.

Variable A:SType.

Definition unpack_r_r_p : set -> (set -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_r (S 1)) (decode_r (S 2)) (decode_p (S 3)).

Theorem unpack_r_r_p_eq : forall Phi:set -> (set -> set -> prop) -> (set -> set -> prop) -> (set -> prop) -> A,
  (forall X, forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X R T P = Phi X R' T' P')
  ->
  forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall P:set -> prop, unpack_r_r_p (pack_r_r_p X R T P) Phi = Phi X R T P.
let Phi.
assume HPhi.
let X R T P.
prove Phi (pack_r_r_p X R T P 0) (decode_r (pack_r_r_p X R T P 1)) (decode_r (pack_r_r_p X R T P 2)) (decode_p (pack_r_r_p X R T P 3)) = Phi X R T P.
rewrite <- struct_r_r_p_0_eq (pack_r_r_p X R T P) X R T P (eqI set (pack_r_r_p X R T P)).
prove Phi X (decode_r (pack_r_r_p X R T P 1)) (decode_r (pack_r_r_p X R T P 2)) (decode_p (pack_r_r_p X R T P 3)) = Phi X R T P.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_r_r_p X R T P 1) x y <-> R x y.
  rewrite <- struct_r_r_p_1_eq (pack_r_r_p X R T P) X R T P (eqI set (pack_r_r_p X R T P)) x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_r_r_p X R T P 2) x y <-> T x y.
  rewrite <- struct_r_r_p_2_eq (pack_r_r_p X R T P) X R T P (eqI set (pack_r_r_p X R T P)) x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove decode_p (pack_r_r_p X R T P 3) x <-> P x.
  rewrite <- struct_r_r_p_3_eq (pack_r_r_p X R T P) X R T P (eqI set (pack_r_r_p X R T P)) x Hx.
  apply iff_refl.
Qed.

End unpack_r_r_p.

Definition pack_r_r_e : set -> (set -> set -> prop) -> (set -> set -> prop) -> set -> set := fun X R T c => (X,encode_r X R,encode_r X T,c).

Definition struct_r_r_e : set -> prop := fun S => exists X:set, exists R:set -> set -> prop, exists T:set -> set -> prop, exists c:set, c :e X /\ S = pack_r_r_e X R T c.

Theorem pack_r_r_e_ext : forall X, forall R R':set -> set -> prop, forall T T':set -> set -> prop, forall c,
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_r_r_e X R T c = pack_r_r_e X R' T' c.
let X R R' T T' c. assume H1. assume H2.
prove (X,encode_r X R,encode_r X T,c) = (X,encode_r X R',encode_r X T',c).
claim L1: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_r_r_e_0_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_r_r_e X R T c -> X = S 0.
let S X R T c. assume H1. rewrite H1.
prove X = (X,encode_r X R,encode_r X T,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_r_r_e_1_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_r_r_e X R T c -> forall x y :e X, R x y = decode_r (S 1) x y.
let S X R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_r X R,encode_r X T,c) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_r_r_e_2_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_r_r_e X R T c -> forall x y :e X, T x y = decode_r (S 2) x y.
let S X R T c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_r X R,encode_r X T,c) 2) x y.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem struct_r_r_e_3_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, S = pack_r_r_e X R T c -> c = S 3.
let S X R T c. assume H1.
rewrite H1. prove c = (X,encode_r X R,encode_r X T,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_r_r_e: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, c :e X -> struct_r_r_e (pack_r_r_e X R T c).
let X R T c.
assume H3.
prove exists X':set, exists R':set -> set -> prop, exists T':set -> set -> prop, exists c':set,  c' :e X' /\ pack_r_r_e X R T c = pack_r_r_e X' R' T' c'.
witness X. witness R. witness T. witness c.
apply andI.
exact H3.
apply eqI set.
Qed.

Theorem struct_r_r_e_eta: forall S, struct_r_r_e S -> S = pack_r_r_e (S 0) (decode_r (S 1)) (decode_r (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let R.
assume H2. apply H2. let T.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_r_r_e_0_eq S X R T c Heq.
prove S = (X,encode_r X (decode_r (S 1)),encode_r X (decode_r (S 2)),S 3).
claim L1: encode_r X R = encode_r X (decode_r (S 1)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_r_r_e_1_eq S X R T c Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L1.
claim L2: encode_r X T = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_r_r_e_2_eq S X R T c Heq x Hx y Hy.
  exact iff_refl (T x y).
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_r_r_e_3_eq S X R T c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_r_r_e.

Variable A:SType.

Definition unpack_r_r_e : set -> (set -> (set -> set -> prop) -> (set -> set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_r (S 1)) (decode_r (S 2)) (S 3).

Theorem unpack_r_r_e_eq : forall Phi:set -> (set -> set -> prop) -> (set -> set -> prop) -> set -> A,
  (forall X, forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) ->  forall c,Phi X R T c = Phi X R' T' c)
  ->
  forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, forall c:set, unpack_r_r_e (pack_r_r_e X R T c) Phi = Phi X R T c.
let Phi.
assume HPhi.
let X R T c.
prove Phi (pack_r_r_e X R T c 0) (decode_r (pack_r_r_e X R T c 1)) (decode_r (pack_r_r_e X R T c 2)) (pack_r_r_e X R T c 3) = Phi X R T c.
rewrite <- struct_r_r_e_0_eq (pack_r_r_e X R T c) X R T c (eqI set (pack_r_r_e X R T c)).
prove Phi X (decode_r (pack_r_r_e X R T c 1)) (decode_r (pack_r_r_e X R T c 2)) (pack_r_r_e X R T c 3) = Phi X R T c.
rewrite <- struct_r_r_e_3_eq (pack_r_r_e X R T c) X R T c (eqI set (pack_r_r_e X R T c)).
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_r_r_e X R T c 1) x y <-> R x y.
  rewrite <- struct_r_r_e_1_eq (pack_r_r_e X R T c) X R T c (eqI set (pack_r_r_e X R T c)) x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_r_r_e X R T c 2) x y <-> T x y.
  rewrite <- struct_r_r_e_2_eq (pack_r_r_e X R T c) X R T c (eqI set (pack_r_r_e X R T c)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_r_r_e.

Definition pack_r_p_e : set -> (set -> set -> prop) -> (set -> prop) -> set -> set := fun X R P c => (X,encode_r X R,encode_p X P,c).

Definition struct_r_p_e : set -> prop := fun S => exists X:set, exists R:set -> set -> prop, exists P:set -> prop, exists c:set, c :e X /\ S = pack_r_p_e X R P c.

Theorem pack_r_p_e_ext : forall X, forall R R':set -> set -> prop, forall P P':set -> prop, forall c,
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_r_p_e X R P c = pack_r_p_e X R' P' c.
let X R R' P P' c. assume H1. assume H2.
prove (X,encode_r X R,encode_p X P,c) = (X,encode_r X R',encode_p X P',c).
claim L1: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H1. }
rewrite <- L1.
claim L2: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_r_p_e_0_eq: forall S X, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_r_p_e X R P c -> X = S 0.
let S X R P c. assume H1. rewrite H1.
prove X = (X,encode_r X R,encode_p X P,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_r_p_e_1_eq: forall S X, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_r_p_e X R P c -> forall x y :e X, R x y = decode_r (S 1) x y.
let S X R P c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_r X R,encode_p X P,c) 1) x y.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_r_p_e_2_eq: forall S X, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_r_p_e X R P c -> forall x :e X, P x = decode_p (S 2) x.
let S X R P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_r X R,encode_p X P,c) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem struct_r_p_e_3_eq: forall S X, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, S = pack_r_p_e X R P c -> c = S 3.
let S X R P c. assume H1.
rewrite H1. prove c = (X,encode_r X R,encode_p X P,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_r_p_e: forall X, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, c :e X -> struct_r_p_e (pack_r_p_e X R P c).
let X R P c.
assume H3.
prove exists X':set, exists R':set -> set -> prop, exists P':set -> prop, exists c':set,  c' :e X' /\ pack_r_p_e X R P c = pack_r_p_e X' R' P' c'.
witness X. witness R. witness P. witness c.
apply andI.
exact H3.
apply eqI set.
Qed.

Theorem struct_r_p_e_eta: forall S, struct_r_p_e S -> S = pack_r_p_e (S 0) (decode_r (S 1)) (decode_p (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let R.
assume H2. apply H2. let P.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_r_p_e_0_eq S X R P c Heq.
prove S = (X,encode_r X (decode_r (S 1)),encode_p X (decode_p (S 2)),S 3).
claim L1: encode_r X R = encode_r X (decode_r (S 1)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_r_p_e_1_eq S X R P c Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L1.
claim L2: encode_p X P = encode_p X (decode_p (S 2)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_r_p_e_2_eq S X R P c Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_r_p_e_3_eq S X R P c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_r_p_e.

Variable A:SType.

Definition unpack_r_p_e : set -> (set -> (set -> set -> prop) -> (set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_r (S 1)) (decode_p (S 2)) (S 3).

Theorem unpack_r_p_e_eq : forall Phi:set -> (set -> set -> prop) -> (set -> prop) -> set -> A,
  (forall X, forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall c,Phi X R P c = Phi X R' P' c)
  ->
  forall X, forall R:set -> set -> prop, forall P:set -> prop, forall c:set, unpack_r_p_e (pack_r_p_e X R P c) Phi = Phi X R P c.
let Phi.
assume HPhi.
let X R P c.
prove Phi (pack_r_p_e X R P c 0) (decode_r (pack_r_p_e X R P c 1)) (decode_p (pack_r_p_e X R P c 2)) (pack_r_p_e X R P c 3) = Phi X R P c.
rewrite <- struct_r_p_e_0_eq (pack_r_p_e X R P c) X R P c (eqI set (pack_r_p_e X R P c)).
prove Phi X (decode_r (pack_r_p_e X R P c 1)) (decode_p (pack_r_p_e X R P c 2)) (pack_r_p_e X R P c 3) = Phi X R P c.
rewrite <- struct_r_p_e_3_eq (pack_r_p_e X R P c) X R P c (eqI set (pack_r_p_e X R P c)).
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_r_p_e X R P c 1) x y <-> R x y.
  rewrite <- struct_r_p_e_1_eq (pack_r_p_e X R P c) X R P c (eqI set (pack_r_p_e X R P c)) x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove decode_p (pack_r_p_e X R P c 2) x <-> P x.
  rewrite <- struct_r_p_e_2_eq (pack_r_p_e X R P c) X R P c (eqI set (pack_r_p_e X R P c)) x Hx.
  apply iff_refl.
Qed.

End unpack_r_p_e.

Definition pack_p_p_e : set -> (set -> prop) -> (set -> prop) -> set -> set := fun X P Q c => (X,encode_p X P,encode_p X Q,c).

Definition struct_p_p_e : set -> prop := fun S => exists X:set, exists P:set -> prop, exists Q:set -> prop, exists c:set, c :e X /\ S = pack_p_p_e X P Q c.

Theorem pack_p_p_e_ext : forall X, forall P P':set -> prop, forall Q Q':set -> prop, forall c,
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_p_p_e X P Q c = pack_p_p_e X P' Q' c.
let X P P' Q Q' c. assume H1. assume H2.
prove (X,encode_p X P,encode_p X Q,c) = (X,encode_p X P',encode_p X Q',c).
claim L1: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H1. }
rewrite <- L1.
claim L2: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_p_p_e_0_eq: forall S X, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_p_p_e X P Q c -> X = S 0.
let S X P Q c. assume H1. rewrite H1.
prove X = (X,encode_p X P,encode_p X Q,c) 0.
apply eq_sym set. apply tuple_4_0_eq.
Qed.

Theorem struct_p_p_e_1_eq: forall S X, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_p_p_e X P Q c -> forall x :e X, P x = decode_p (S 1) x.
let S X P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_p X P,encode_p X Q,c) 1) x.
rewrite tuple_4_1_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem struct_p_p_e_2_eq: forall S X, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_p_p_e X P Q c -> forall x :e X, Q x = decode_p (S 2) x.
let S X P Q c. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_p X P,encode_p X Q,c) 2) x.
rewrite tuple_4_2_eq.
apply eq_sym prop. exact decode_encode_p X Q x Hx.
Qed.

Theorem struct_p_p_e_3_eq: forall S X, forall P:set -> prop, forall Q:set -> prop, forall c:set, S = pack_p_p_e X P Q c -> c = S 3.
let S X P Q c. assume H1.
rewrite H1. prove c = (X,encode_p X P,encode_p X Q,c) 3. apply eq_sym set. apply tuple_4_3_eq.
Qed.

Theorem pack_struct_p_p_e: forall X, forall P:set -> prop, forall Q:set -> prop, forall c:set, c :e X -> struct_p_p_e (pack_p_p_e X P Q c).
let X P Q c.
assume H3.
prove exists X':set, exists P':set -> prop, exists Q':set -> prop, exists c':set,  c' :e X' /\ pack_p_p_e X P Q c = pack_p_p_e X' P' Q' c'.
witness X. witness P. witness Q. witness c.
apply andI.
exact H3.
apply eqI set.
Qed.

Theorem struct_p_p_e_eta: forall S, struct_p_p_e S -> S = pack_p_p_e (S 0) (decode_p (S 1)) (decode_p (S 2)) (S 3).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let P.
assume H2. apply H2. let Q.
assume H3. apply H3. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_p_p_e_0_eq S X P Q c Heq.
prove S = (X,encode_p X (decode_p (S 1)),encode_p X (decode_p (S 2)),S 3).
claim L1: encode_p X P = encode_p X (decode_p (S 1)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_p_p_e_1_eq S X P Q c Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L1.
claim L2: encode_p X Q = encode_p X (decode_p (S 2)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_p_p_e_2_eq S X P Q c Heq x Hx.
  exact iff_refl (Q x).
}
rewrite <- L2.
claim L3: c = (S 3).
{ exact struct_p_p_e_3_eq S X P Q c Heq. }
rewrite <- L3.
exact Heq.
Qed.

Section unpack_p_p_e.

Variable A:SType.

Definition unpack_p_p_e : set -> (set -> (set -> prop) -> (set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_p (S 1)) (decode_p (S 2)) (S 3).

Theorem unpack_p_p_e_eq : forall Phi:set -> (set -> prop) -> (set -> prop) -> set -> A,
  (forall X, forall P P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q Q':set -> prop, (forall x :e X, Q x <-> Q' x) ->  forall c,Phi X P Q c = Phi X P' Q' c)
  ->
  forall X, forall P:set -> prop, forall Q:set -> prop, forall c:set, unpack_p_p_e (pack_p_p_e X P Q c) Phi = Phi X P Q c.
let Phi.
assume HPhi.
let X P Q c.
prove Phi (pack_p_p_e X P Q c 0) (decode_p (pack_p_p_e X P Q c 1)) (decode_p (pack_p_p_e X P Q c 2)) (pack_p_p_e X P Q c 3) = Phi X P Q c.
rewrite <- struct_p_p_e_0_eq (pack_p_p_e X P Q c) X P Q c (eqI set (pack_p_p_e X P Q c)).
prove Phi X (decode_p (pack_p_p_e X P Q c 1)) (decode_p (pack_p_p_e X P Q c 2)) (pack_p_p_e X P Q c 3) = Phi X P Q c.
rewrite <- struct_p_p_e_3_eq (pack_p_p_e X P Q c) X P Q c (eqI set (pack_p_p_e X P Q c)).
apply HPhi.
- let x. assume Hx.
  prove decode_p (pack_p_p_e X P Q c 1) x <-> P x.
  rewrite <- struct_p_p_e_1_eq (pack_p_p_e X P Q c) X P Q c (eqI set (pack_p_p_e X P Q c)) x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove decode_p (pack_p_p_e X P Q c 2) x <-> Q x.
  rewrite <- struct_p_p_e_2_eq (pack_p_p_e X P Q c) X P Q c (eqI set (pack_p_p_e X P Q c)) x Hx.
  apply iff_refl.
Qed.

End unpack_p_p_e.

