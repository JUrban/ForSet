Definition pack_c_b : set -> ((set -> prop) -> prop) -> (set -> set -> set) -> set := fun X C f => (X,encode_c X C,encode_b X f).

Definition struct_c_b : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists f:set -> set -> set, (forall x y :e X, f x y :e X) /\ S = pack_c_b X C f.

Theorem pack_c_b_ext : forall X, forall C C':(set -> prop) -> prop, forall f f':set -> set -> set,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, f x y = f' x y) ->
 pack_c_b X C f = pack_c_b X C' f'.
let X C C' f f'. assume H1. assume H2.
prove (X,encode_c X C,encode_b X f) = (X,encode_c X C',encode_b X f').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_c_b_0_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, S = pack_c_b X C f -> X = S 0.
let S X C f. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_b X f) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_c_b_1_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, S = pack_c_b X C f -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C f. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_b X f) 1) U.
rewrite tuple_3_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_b_2_eq: forall S X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, S = pack_c_b X C f -> forall x y :e X, f x y = decode_b (S 2) x y.
let S X C f. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_c X C,encode_b X f) 2) x y.
rewrite tuple_3_2_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem pack_struct_c_b: forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, (forall x y :e X, f x y :e X) -> struct_c_b (pack_c_b X C f).
let X C f.
assume H2.
prove exists X':set, exists C':(set -> prop) -> prop, exists f':set -> set -> set,  (forall x y :e X', f' x y :e X') /\ pack_c_b X C f = pack_c_b X' C' f'.
witness X. witness C. witness f.
apply andI.
exact H2.
apply eqI set.
Qed.

Theorem struct_c_b_eta: forall S, struct_c_b S -> S = pack_c_b (S 0) (decode_c (S 1)) (decode_b (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let f.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_b_0_eq S X C f Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_b X (decode_b (S 2))).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_b_1_eq S X C f Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_b X f = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_c_b_2_eq S X C f Heq.
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_c_b.

Variable A:SType.

Definition unpack_c_b : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> set) -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_b (S 2)).

Theorem unpack_c_b_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> set) -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) -> Phi X C f = Phi X C' f')
  ->
  forall X, forall C:(set -> prop) -> prop, forall f:set -> set -> set, unpack_c_b (pack_c_b X C f) Phi = Phi X C f.
let Phi.
assume HPhi.
let X C f.
prove Phi (pack_c_b X C f 0) (decode_c (pack_c_b X C f 1)) (decode_b (pack_c_b X C f 2)) = Phi X C f.
rewrite <- struct_c_b_0_eq (pack_c_b X C f) X C f (eqI set (pack_c_b X C f)).
prove Phi X (decode_c (pack_c_b X C f 1)) (decode_b (pack_c_b X C f 2)) = Phi X C f.
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_b X C f 1) U <-> C U.
  rewrite <- struct_c_b_1_eq (pack_c_b X C f) X C f (eqI set (pack_c_b X C f)) U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_c_b X C f 2) x y = f x y.
  apply eq_sym set.
  exact struct_c_b_2_eq (pack_c_b X C f) X C f (eqI set (pack_c_b X C f)) x Hx y Hy.
Qed.

End unpack_c_b.

Definition pack_c_u : set -> ((set -> prop) -> prop) -> (set -> set) -> set := fun X C i => (X,encode_c X C,encode_u X i).

Definition struct_c_u : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists i:set -> set, (forall x :e X, i x :e X) /\ S = pack_c_u X C i.

Theorem pack_c_u_ext : forall X, forall C C':(set -> prop) -> prop, forall i i':set -> set,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, i x = i' x) ->
 pack_c_u X C i = pack_c_u X C' i'.
let X C C' i i'. assume H1. assume H2.
prove (X,encode_c X C,encode_u X i) = (X,encode_c X C',encode_u X i').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_c_u_0_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, S = pack_c_u X C i -> X = S 0.
let S X C i. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_u X i) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_c_u_1_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, S = pack_c_u X C i -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C i. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_u X i) 1) U.
rewrite tuple_3_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_u_2_eq: forall S X, forall C:(set -> prop) -> prop, forall i:set -> set, S = pack_c_u X C i -> forall x :e X, i x = decode_u (S 2) x.
let S X C i. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_c X C,encode_u X i) 2) x.
rewrite tuple_3_2_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_struct_c_u: forall X, forall C:(set -> prop) -> prop, forall i:set -> set, (forall x :e X, i x :e X) -> struct_c_u (pack_c_u X C i).
let X C i.
assume H2.
prove exists X':set, exists C':(set -> prop) -> prop, exists i':set -> set,  (forall x :e X', i' x :e X') /\ pack_c_u X C i = pack_c_u X' C' i'.
witness X. witness C. witness i.
apply andI.
exact H2.
apply eqI set.
Qed.

Theorem struct_c_u_eta: forall S, struct_c_u S -> S = pack_c_u (S 0) (decode_c (S 1)) (decode_u (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let i.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_u_0_eq S X C i Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_u X (decode_u (S 2))).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_u_1_eq S X C i Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_u X i = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_c_u_2_eq S X C i Heq.
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_c_u.

Variable A:SType.

Definition unpack_c_u : set -> (set -> ((set -> prop) -> prop) -> (set -> set) -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_u (S 2)).

Theorem unpack_c_u_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set) -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall i i':set -> set, (forall x :e X, i x = i' x) -> Phi X C i = Phi X C' i')
  ->
  forall X, forall C:(set -> prop) -> prop, forall i:set -> set, unpack_c_u (pack_c_u X C i) Phi = Phi X C i.
let Phi.
assume HPhi.
let X C i.
prove Phi (pack_c_u X C i 0) (decode_c (pack_c_u X C i 1)) (decode_u (pack_c_u X C i 2)) = Phi X C i.
rewrite <- struct_c_u_0_eq (pack_c_u X C i) X C i (eqI set (pack_c_u X C i)).
prove Phi X (decode_c (pack_c_u X C i 1)) (decode_u (pack_c_u X C i 2)) = Phi X C i.
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_u X C i 1) U <-> C U.
  rewrite <- struct_c_u_1_eq (pack_c_u X C i) X C i (eqI set (pack_c_u X C i)) U HU.
  apply iff_refl.
- let x. assume Hx.
  prove decode_u (pack_c_u X C i 2) x = i x.
  apply eq_sym set.
  exact struct_c_u_2_eq (pack_c_u X C i) X C i (eqI set (pack_c_u X C i)) x Hx.
Qed.

End unpack_c_u.

Definition pack_c_r : set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> set := fun X C R => (X,encode_c X C,encode_r X R).

Definition struct_c_r : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists R:set -> set -> prop, S = pack_c_r X C R.

Theorem pack_c_r_ext : forall X, forall C C':(set -> prop) -> prop, forall R R':set -> set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_c_r X C R = pack_c_r X C' R'.
let X C C' R R'. assume H1. assume H2.
prove (X,encode_c X C,encode_r X R) = (X,encode_c X C',encode_r X R').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_c_r_0_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, S = pack_c_r X C R -> X = S 0.
let S X C R. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_r X R) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_c_r_1_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, S = pack_c_r X C R -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C R. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_r X R) 1) U.
rewrite tuple_3_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_r_2_eq: forall S X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, S = pack_c_r X C R -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X C R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_c X C,encode_r X R) 2) x y.
rewrite tuple_3_2_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_struct_c_r: forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, struct_c_r (pack_c_r X C R).
let X C R.
prove exists X':set, exists C':(set -> prop) -> prop, exists R':set -> set -> prop,  pack_c_r X C R = pack_c_r X' C' R'.
witness X. witness C. witness R.
apply eqI set.
Qed.

Theorem struct_c_r_eta: forall S, struct_c_r S -> S = pack_c_r (S 0) (decode_c (S 1)) (decode_r (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let R.
assume Heq.
rewrite <- struct_c_r_0_eq S X C R Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_r X (decode_r (S 2))).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_r_1_eq S X C R Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_r X R = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_c_r_2_eq S X C R Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_c_r.

Variable A:SType.

Definition unpack_c_r : set -> (set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_r (S 2)).

Theorem unpack_c_r_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> set -> prop) -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X C R = Phi X C' R')
  ->
  forall X, forall C:(set -> prop) -> prop, forall R:set -> set -> prop, unpack_c_r (pack_c_r X C R) Phi = Phi X C R.
let Phi.
assume HPhi.
let X C R.
prove Phi (pack_c_r X C R 0) (decode_c (pack_c_r X C R 1)) (decode_r (pack_c_r X C R 2)) = Phi X C R.
rewrite <- struct_c_r_0_eq (pack_c_r X C R) X C R (eqI set (pack_c_r X C R)).
prove Phi X (decode_c (pack_c_r X C R 1)) (decode_r (pack_c_r X C R 2)) = Phi X C R.
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_r X C R 1) U <-> C U.
  rewrite <- struct_c_r_1_eq (pack_c_r X C R) X C R (eqI set (pack_c_r X C R)) U HU.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_c_r X C R 2) x y <-> R x y.
  rewrite <- struct_c_r_2_eq (pack_c_r X C R) X C R (eqI set (pack_c_r X C R)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_c_r.

Definition pack_c_p : set -> ((set -> prop) -> prop) -> (set -> prop) -> set := fun X C P => (X,encode_c X C,encode_p X P).

Definition struct_c_p : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists P:set -> prop, S = pack_c_p X C P.

Theorem pack_c_p_ext : forall X, forall C C':(set -> prop) -> prop, forall P P':set -> prop,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 (forall x :e X, P x <-> P' x) ->
 pack_c_p X C P = pack_c_p X C' P'.
let X C C' P P'. assume H1. assume H2.
prove (X,encode_c X C,encode_p X P) = (X,encode_c X C',encode_p X P').
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
claim L2: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_c_p_0_eq: forall S X, forall C:(set -> prop) -> prop, forall P:set -> prop, S = pack_c_p X C P -> X = S 0.
let S X C P. assume H1. rewrite H1.
prove X = (X,encode_c X C,encode_p X P) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_c_p_1_eq: forall S X, forall C:(set -> prop) -> prop, forall P:set -> prop, S = pack_c_p X C P -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C P. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,encode_p X P) 1) U.
rewrite tuple_3_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_p_2_eq: forall S X, forall C:(set -> prop) -> prop, forall P:set -> prop, S = pack_c_p X C P -> forall x :e X, P x = decode_p (S 2) x.
let S X C P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_c X C,encode_p X P) 2) x.
rewrite tuple_3_2_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_c_p: forall X, forall C:(set -> prop) -> prop, forall P:set -> prop, struct_c_p (pack_c_p X C P).
let X C P.
prove exists X':set, exists C':(set -> prop) -> prop, exists P':set -> prop,  pack_c_p X C P = pack_c_p X' C' P'.
witness X. witness C. witness P.
apply eqI set.
Qed.

Theorem struct_c_p_eta: forall S, struct_c_p S -> S = pack_c_p (S 0) (decode_c (S 1)) (decode_p (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let P.
assume Heq.
rewrite <- struct_c_p_0_eq S X C P Heq.
prove S = (X,encode_c X (decode_c (S 1)),encode_p X (decode_p (S 2))).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_p_1_eq S X C P Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: encode_p X P = encode_p X (decode_p (S 2)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_c_p_2_eq S X C P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_c_p.

Variable A:SType.

Definition unpack_c_p : set -> (set -> ((set -> prop) -> prop) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (decode_p (S 2)).

Theorem unpack_c_p_eq : forall Phi:set -> ((set -> prop) -> prop) -> (set -> prop) -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X C P = Phi X C' P')
  ->
  forall X, forall C:(set -> prop) -> prop, forall P:set -> prop, unpack_c_p (pack_c_p X C P) Phi = Phi X C P.
let Phi.
assume HPhi.
let X C P.
prove Phi (pack_c_p X C P 0) (decode_c (pack_c_p X C P 1)) (decode_p (pack_c_p X C P 2)) = Phi X C P.
rewrite <- struct_c_p_0_eq (pack_c_p X C P) X C P (eqI set (pack_c_p X C P)).
prove Phi X (decode_c (pack_c_p X C P 1)) (decode_p (pack_c_p X C P 2)) = Phi X C P.
apply HPhi.
- let U. assume HU.
  prove decode_c (pack_c_p X C P 1) U <-> C U.
  rewrite <- struct_c_p_1_eq (pack_c_p X C P) X C P (eqI set (pack_c_p X C P)) U HU.
  apply iff_refl.
- let x. assume Hx.
  prove decode_p (pack_c_p X C P 2) x <-> P x.
  rewrite <- struct_c_p_2_eq (pack_c_p X C P) X C P (eqI set (pack_c_p X C P)) x Hx.
  apply iff_refl.
Qed.

End unpack_c_p.

Definition pack_c_e : set -> ((set -> prop) -> prop) -> set -> set := fun X C c => (X,encode_c X C,c).

Definition struct_c_e : set -> prop := fun S => exists X:set, exists C:(set -> prop) -> prop, exists c:set, c :e X /\ S = pack_c_e X C c.

Theorem pack_c_e_ext : forall X, forall C C':(set -> prop) -> prop, forall c,
 (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->
 pack_c_e X C c = pack_c_e X C' c.
let X C C' c. assume H1.
prove (X,encode_c X C,c) = (X,encode_c X C',c).
claim L1: encode_c X C = encode_c X C'.
{ apply encode_c_ext. exact H1. }
rewrite <- L1.
apply eqI set.
Qed.

Theorem struct_c_e_0_eq: forall S X, forall C:(set -> prop) -> prop, forall c:set, S = pack_c_e X C c -> X = S 0.
let S X C c. assume H1. rewrite H1.
prove X = (X,encode_c X C,c) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_c_e_1_eq: forall S X, forall C:(set -> prop) -> prop, forall c:set, S = pack_c_e X C c -> forall U:set -> prop, (forall x, U x -> x :e X) -> C U = decode_c (S 1) U.
let S X C c. assume H1.
let U. assume HU. rewrite H1.
prove C U = decode_c ((X,encode_c X C,c) 1) U.
rewrite tuple_3_1_eq.
apply eq_sym prop. exact decode_encode_c X C U HU.
Qed.

Theorem struct_c_e_2_eq: forall S X, forall C:(set -> prop) -> prop, forall c:set, S = pack_c_e X C c -> c = S 2.
let S X C c. assume H1.
rewrite H1. prove c = (X,encode_c X C,c) 2. apply eq_sym set. apply tuple_3_2_eq.
Qed.

Theorem pack_struct_c_e: forall X, forall C:(set -> prop) -> prop, forall c:set, c :e X -> struct_c_e (pack_c_e X C c).
let X C c.
assume H2.
prove exists X':set, exists C':(set -> prop) -> prop, exists c':set,  c' :e X' /\ pack_c_e X C c = pack_c_e X' C' c'.
witness X. witness C. witness c.
apply andI.
exact H2.
apply eqI set.
Qed.

Theorem struct_c_e_eta: forall S, struct_c_e S -> S = pack_c_e (S 0) (decode_c (S 1)) (S 2).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let C.
assume H2. apply H2. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_c_e_0_eq S X C c Heq.
prove S = (X,encode_c X (decode_c (S 1)),S 2).
claim L1: encode_c X C = encode_c X (decode_c (S 1)).
{ apply encode_c_ext.
  let U. assume HU.
  rewrite <- struct_c_e_1_eq S X C c Heq U HU.
  exact iff_refl (C U).
}
rewrite <- L1.
claim L2: c = (S 2).
{ exact struct_c_e_2_eq S X C c Heq. }
rewrite <- L2.
exact Heq.
Qed.

Section unpack_c_e.

Variable A:SType.

Definition unpack_c_e : set -> (set -> ((set -> prop) -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_c (S 1)) (S 2).

Theorem unpack_c_e_eq : forall Phi:set -> ((set -> prop) -> prop) -> set -> A,
  (forall X, forall C C':(set -> prop) -> prop, (forall U:set -> prop, (forall x, U x -> x :e X) -> (C U <-> C' U)) ->  forall c,Phi X C c = Phi X C' c)
  ->
  forall X, forall C:(set -> prop) -> prop, forall c:set, unpack_c_e (pack_c_e X C c) Phi = Phi X C c.
let Phi.
assume HPhi.
let X C c.
prove Phi (pack_c_e X C c 0) (decode_c (pack_c_e X C c 1)) (pack_c_e X C c 2) = Phi X C c.
rewrite <- struct_c_e_0_eq (pack_c_e X C c) X C c (eqI set (pack_c_e X C c)).
prove Phi X (decode_c (pack_c_e X C c 1)) (pack_c_e X C c 2) = Phi X C c.
rewrite <- struct_c_e_2_eq (pack_c_e X C c) X C c (eqI set (pack_c_e X C c)).
apply HPhi.
let U. assume HU.
prove decode_c (pack_c_e X C c 1) U <-> C U.
rewrite <- struct_c_e_1_eq (pack_c_e X C c) X C c (eqI set (pack_c_e X C c)) U HU.
apply iff_refl.
Qed.

End unpack_c_e.

Definition pack_b_b : set -> (set -> set -> set) -> (set -> set -> set) -> set := fun X f g => (X,encode_b X f,encode_b X g).

Definition struct_b_b : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists g:set -> set -> set, (forall x y :e X, f x y :e X) /\ (forall x y :e X, g x y :e X) /\ S = pack_b_b X f g.

Theorem pack_b_b_ext : forall X, forall f f':set -> set -> set, forall g g':set -> set -> set,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, g x y = g' x y) ->
 pack_b_b X f g = pack_b_b X f' g'.
let X f f' g g'. assume H1. assume H2.
prove (X,encode_b X f,encode_b X g) = (X,encode_b X f',encode_b X g').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_b X g = encode_b X g'.
{ apply encode_b_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_b_b_0_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, S = pack_b_b X f g -> X = S 0.
let S X f g. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_b X g) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_b_b_1_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, S = pack_b_b X f g -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f g. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_b X g) 1) x y.
rewrite tuple_3_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_b_2_eq: forall S X, forall f:set -> set -> set, forall g:set -> set -> set, S = pack_b_b X f g -> forall x y :e X, g x y = decode_b (S 2) x y.
let S X f g. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove g x y = decode_b ((X,encode_b X f,encode_b X g) 2) x y.
rewrite tuple_3_2_eq.
apply eq_sym set. exact decode_encode_b X g x Hx y Hy.
Qed.

Theorem pack_struct_b_b: forall X, forall f:set -> set -> set, forall g:set -> set -> set, (forall x y :e X, f x y :e X) -> (forall x y :e X, g x y :e X) -> struct_b_b (pack_b_b X f g).
let X f g.
assume H1.
assume H2.
prove exists X':set, exists f':set -> set -> set, exists g':set -> set -> set,  (forall x y :e X', f' x y :e X') /\ (forall x y :e X', g' x y :e X') /\ pack_b_b X f g = pack_b_b X' f' g'.
witness X. witness f. witness g.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_b_b_eta: forall S, struct_b_b S -> S = pack_b_b (S 0) (decode_b (S 1)) (decode_b (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let g.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_b_0_eq S X f g Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_b X (decode_b (S 2))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_b_1_eq S X f g Heq.
}
rewrite <- L1.
claim L2: encode_b X g = encode_b X (decode_b (S 2)).
{ apply encode_b_ext.
  exact struct_b_b_2_eq S X f g Heq.
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_b_b.

Variable A:SType.

Definition unpack_b_b : set -> (set -> (set -> set -> set) -> (set -> set -> set) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_b (S 2)).

Theorem unpack_b_b_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> set) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall g g':set -> set -> set, (forall x y :e X, g x y = g' x y) -> Phi X f g = Phi X f' g')
  ->
  forall X, forall f:set -> set -> set, forall g:set -> set -> set, unpack_b_b (pack_b_b X f g) Phi = Phi X f g.
let Phi.
assume HPhi.
let X f g.
prove Phi (pack_b_b X f g 0) (decode_b (pack_b_b X f g 1)) (decode_b (pack_b_b X f g 2)) = Phi X f g.
rewrite <- struct_b_b_0_eq (pack_b_b X f g) X f g (eqI set (pack_b_b X f g)).
prove Phi X (decode_b (pack_b_b X f g 1)) (decode_b (pack_b_b X f g 2)) = Phi X f g.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b X f g 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_b_1_eq (pack_b_b X f g) X f g (eqI set (pack_b_b X f g)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_b X f g 2) x y = g x y.
  apply eq_sym set.
  exact struct_b_b_2_eq (pack_b_b X f g) X f g (eqI set (pack_b_b X f g)) x Hx y Hy.
Qed.

End unpack_b_b.

Definition pack_b_u : set -> (set -> set -> set) -> (set -> set) -> set := fun X f i => (X,encode_b X f,encode_u X i).

Definition struct_b_u : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists i:set -> set, (forall x y :e X, f x y :e X) /\ (forall x :e X, i x :e X) /\ S = pack_b_u X f i.

Theorem pack_b_u_ext : forall X, forall f f':set -> set -> set, forall i i':set -> set,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, i x = i' x) ->
 pack_b_u X f i = pack_b_u X f' i'.
let X f f' i i'. assume H1. assume H2.
prove (X,encode_b X f,encode_u X i) = (X,encode_b X f',encode_u X i').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_b_u_0_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, S = pack_b_u X f i -> X = S 0.
let S X f i. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_u X i) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_b_u_1_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, S = pack_b_u X f i -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f i. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_u X i) 1) x y.
rewrite tuple_3_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_u_2_eq: forall S X, forall f:set -> set -> set, forall i:set -> set, S = pack_b_u X f i -> forall x :e X, i x = decode_u (S 2) x.
let S X f i. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_b X f,encode_u X i) 2) x.
rewrite tuple_3_2_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem pack_struct_b_u: forall X, forall f:set -> set -> set, forall i:set -> set, (forall x y :e X, f x y :e X) -> (forall x :e X, i x :e X) -> struct_b_u (pack_b_u X f i).
let X f i.
assume H1.
assume H2.
prove exists X':set, exists f':set -> set -> set, exists i':set -> set,  (forall x y :e X', f' x y :e X') /\ (forall x :e X', i' x :e X') /\ pack_b_u X f i = pack_b_u X' f' i'.
witness X. witness f. witness i.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_b_u_eta: forall S, struct_b_u S -> S = pack_b_u (S 0) (decode_b (S 1)) (decode_u (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let i.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_u_0_eq S X f i Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_u X (decode_u (S 2))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_u_1_eq S X f i Heq.
}
rewrite <- L1.
claim L2: encode_u X i = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_b_u_2_eq S X f i Heq.
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_b_u.

Variable A:SType.

Definition unpack_b_u : set -> (set -> (set -> set -> set) -> (set -> set) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_u (S 2)).

Theorem unpack_b_u_eq : forall Phi:set -> (set -> set -> set) -> (set -> set) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall i i':set -> set, (forall x :e X, i x = i' x) -> Phi X f i = Phi X f' i')
  ->
  forall X, forall f:set -> set -> set, forall i:set -> set, unpack_b_u (pack_b_u X f i) Phi = Phi X f i.
let Phi.
assume HPhi.
let X f i.
prove Phi (pack_b_u X f i 0) (decode_b (pack_b_u X f i 1)) (decode_u (pack_b_u X f i 2)) = Phi X f i.
rewrite <- struct_b_u_0_eq (pack_b_u X f i) X f i (eqI set (pack_b_u X f i)).
prove Phi X (decode_b (pack_b_u X f i 1)) (decode_u (pack_b_u X f i 2)) = Phi X f i.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_u X f i 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_u_1_eq (pack_b_u X f i) X f i (eqI set (pack_b_u X f i)) x Hx y Hy.
- let x. assume Hx.
  prove decode_u (pack_b_u X f i 2) x = i x.
  apply eq_sym set.
  exact struct_b_u_2_eq (pack_b_u X f i) X f i (eqI set (pack_b_u X f i)) x Hx.
Qed.

End unpack_b_u.

Definition pack_b_r : set -> (set -> set -> set) -> (set -> set -> prop) -> set := fun X f R => (X,encode_b X f,encode_r X R).

Definition struct_b_r : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists R:set -> set -> prop, (forall x y :e X, f x y :e X) /\ S = pack_b_r X f R.

Theorem pack_b_r_ext : forall X, forall f f':set -> set -> set, forall R R':set -> set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_b_r X f R = pack_b_r X f' R'.
let X f f' R R'. assume H1. assume H2.
prove (X,encode_b X f,encode_r X R) = (X,encode_b X f',encode_r X R').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_b_r_0_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, S = pack_b_r X f R -> X = S 0.
let S X f R. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_r X R) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_b_r_1_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, S = pack_b_r X f R -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_r X R) 1) x y.
rewrite tuple_3_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_r_2_eq: forall S X, forall f:set -> set -> set, forall R:set -> set -> prop, S = pack_b_r X f R -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X f R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_b X f,encode_r X R) 2) x y.
rewrite tuple_3_2_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_struct_b_r: forall X, forall f:set -> set -> set, forall R:set -> set -> prop, (forall x y :e X, f x y :e X) -> struct_b_r (pack_b_r X f R).
let X f R.
assume H1.
prove exists X':set, exists f':set -> set -> set, exists R':set -> set -> prop,  (forall x y :e X', f' x y :e X') /\ pack_b_r X f R = pack_b_r X' f' R'.
witness X. witness f. witness R.
apply andI.
exact H1.
apply eqI set.
Qed.

Theorem struct_b_r_eta: forall S, struct_b_r S -> S = pack_b_r (S 0) (decode_b (S 1)) (decode_r (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let R.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_r_0_eq S X f R Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_r X (decode_r (S 2))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_r_1_eq S X f R Heq.
}
rewrite <- L1.
claim L2: encode_r X R = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_b_r_2_eq S X f R Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_b_r.

Variable A:SType.

Definition unpack_b_r : set -> (set -> (set -> set -> set) -> (set -> set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_r (S 2)).

Theorem unpack_b_r_eq : forall Phi:set -> (set -> set -> set) -> (set -> set -> prop) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X f R = Phi X f' R')
  ->
  forall X, forall f:set -> set -> set, forall R:set -> set -> prop, unpack_b_r (pack_b_r X f R) Phi = Phi X f R.
let Phi.
assume HPhi.
let X f R.
prove Phi (pack_b_r X f R 0) (decode_b (pack_b_r X f R 1)) (decode_r (pack_b_r X f R 2)) = Phi X f R.
rewrite <- struct_b_r_0_eq (pack_b_r X f R) X f R (eqI set (pack_b_r X f R)).
prove Phi X (decode_b (pack_b_r X f R 1)) (decode_r (pack_b_r X f R 2)) = Phi X f R.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_r X f R 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_r_1_eq (pack_b_r X f R) X f R (eqI set (pack_b_r X f R)) x Hx y Hy.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_b_r X f R 2) x y <-> R x y.
  rewrite <- struct_b_r_2_eq (pack_b_r X f R) X f R (eqI set (pack_b_r X f R)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_b_r.

Definition pack_b_p : set -> (set -> set -> set) -> (set -> prop) -> set := fun X f P => (X,encode_b X f,encode_p X P).

Definition struct_b_p : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists P:set -> prop, (forall x y :e X, f x y :e X) /\ S = pack_b_p X f P.

Theorem pack_b_p_ext : forall X, forall f f':set -> set -> set, forall P P':set -> prop,
 (forall x y :e X, f x y = f' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_b_p X f P = pack_b_p X f' P'.
let X f f' P P'. assume H1. assume H2.
prove (X,encode_b X f,encode_p X P) = (X,encode_b X f',encode_p X P').
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
claim L2: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_b_p_0_eq: forall S X, forall f:set -> set -> set, forall P:set -> prop, S = pack_b_p X f P -> X = S 0.
let S X f P. assume H1. rewrite H1.
prove X = (X,encode_b X f,encode_p X P) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_b_p_1_eq: forall S X, forall f:set -> set -> set, forall P:set -> prop, S = pack_b_p X f P -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,encode_p X P) 1) x y.
rewrite tuple_3_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_p_2_eq: forall S X, forall f:set -> set -> set, forall P:set -> prop, S = pack_b_p X f P -> forall x :e X, P x = decode_p (S 2) x.
let S X f P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_b X f,encode_p X P) 2) x.
rewrite tuple_3_2_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_b_p: forall X, forall f:set -> set -> set, forall P:set -> prop, (forall x y :e X, f x y :e X) -> struct_b_p (pack_b_p X f P).
let X f P.
assume H1.
prove exists X':set, exists f':set -> set -> set, exists P':set -> prop,  (forall x y :e X', f' x y :e X') /\ pack_b_p X f P = pack_b_p X' f' P'.
witness X. witness f. witness P.
apply andI.
exact H1.
apply eqI set.
Qed.

Theorem struct_b_p_eta: forall S, struct_b_p S -> S = pack_b_p (S 0) (decode_b (S 1)) (decode_p (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let P.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_p_0_eq S X f P Heq.
prove S = (X,encode_b X (decode_b (S 1)),encode_p X (decode_p (S 2))).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_p_1_eq S X f P Heq.
}
rewrite <- L1.
claim L2: encode_p X P = encode_p X (decode_p (S 2)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_b_p_2_eq S X f P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_b_p.

Variable A:SType.

Definition unpack_b_p : set -> (set -> (set -> set -> set) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (decode_p (S 2)).

Theorem unpack_b_p_eq : forall Phi:set -> (set -> set -> set) -> (set -> prop) -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X f P = Phi X f' P')
  ->
  forall X, forall f:set -> set -> set, forall P:set -> prop, unpack_b_p (pack_b_p X f P) Phi = Phi X f P.
let Phi.
assume HPhi.
let X f P.
prove Phi (pack_b_p X f P 0) (decode_b (pack_b_p X f P 1)) (decode_p (pack_b_p X f P 2)) = Phi X f P.
rewrite <- struct_b_p_0_eq (pack_b_p X f P) X f P (eqI set (pack_b_p X f P)).
prove Phi X (decode_b (pack_b_p X f P 1)) (decode_p (pack_b_p X f P 2)) = Phi X f P.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_b (pack_b_p X f P 1) x y = f x y.
  apply eq_sym set.
  exact struct_b_p_1_eq (pack_b_p X f P) X f P (eqI set (pack_b_p X f P)) x Hx y Hy.
- let x. assume Hx.
  prove decode_p (pack_b_p X f P 2) x <-> P x.
  rewrite <- struct_b_p_2_eq (pack_b_p X f P) X f P (eqI set (pack_b_p X f P)) x Hx.
  apply iff_refl.
Qed.

End unpack_b_p.

Definition pack_b_e : set -> (set -> set -> set) -> set -> set := fun X f c => (X,encode_b X f,c).

Definition struct_b_e : set -> prop := fun S => exists X:set, exists f:set -> set -> set, exists c:set, (forall x y :e X, f x y :e X) /\ c :e X /\ S = pack_b_e X f c.

Theorem pack_b_e_ext : forall X, forall f f':set -> set -> set, forall c,
 (forall x y :e X, f x y = f' x y) ->
 pack_b_e X f c = pack_b_e X f' c.
let X f f' c. assume H1.
prove (X,encode_b X f,c) = (X,encode_b X f',c).
claim L1: encode_b X f = encode_b X f'.
{ apply encode_b_ext. exact H1. }
rewrite <- L1.
apply eqI set.
Qed.

Theorem struct_b_e_0_eq: forall S X, forall f:set -> set -> set, forall c:set, S = pack_b_e X f c -> X = S 0.
let S X f c. assume H1. rewrite H1.
prove X = (X,encode_b X f,c) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_b_e_1_eq: forall S X, forall f:set -> set -> set, forall c:set, S = pack_b_e X f c -> forall x y :e X, f x y = decode_b (S 1) x y.
let S X f c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove f x y = decode_b ((X,encode_b X f,c) 1) x y.
rewrite tuple_3_1_eq.
apply eq_sym set. exact decode_encode_b X f x Hx y Hy.
Qed.

Theorem struct_b_e_2_eq: forall S X, forall f:set -> set -> set, forall c:set, S = pack_b_e X f c -> c = S 2.
let S X f c. assume H1.
rewrite H1. prove c = (X,encode_b X f,c) 2. apply eq_sym set. apply tuple_3_2_eq.
Qed.

Theorem pack_struct_b_e: forall X, forall f:set -> set -> set, forall c:set, (forall x y :e X, f x y :e X) -> c :e X -> struct_b_e (pack_b_e X f c).
let X f c.
assume H1.
assume H2.
prove exists X':set, exists f':set -> set -> set, exists c':set,  (forall x y :e X', f' x y :e X') /\ c' :e X' /\ pack_b_e X f c = pack_b_e X' f' c'.
witness X. witness f. witness c.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_b_e_eta: forall S, struct_b_e S -> S = pack_b_e (S 0) (decode_b (S 1)) (S 2).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let f.
assume H2. apply H2. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_b_e_0_eq S X f c Heq.
prove S = (X,encode_b X (decode_b (S 1)),S 2).
claim L1: encode_b X f = encode_b X (decode_b (S 1)).
{ apply encode_b_ext.
  exact struct_b_e_1_eq S X f c Heq.
}
rewrite <- L1.
claim L2: c = (S 2).
{ exact struct_b_e_2_eq S X f c Heq. }
rewrite <- L2.
exact Heq.
Qed.

Section unpack_b_e.

Variable A:SType.

Definition unpack_b_e : set -> (set -> (set -> set -> set) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_b (S 1)) (S 2).

Theorem unpack_b_e_eq : forall Phi:set -> (set -> set -> set) -> set -> A,
  (forall X, forall f f':set -> set -> set, (forall x y :e X, f x y = f' x y) ->  forall c,Phi X f c = Phi X f' c)
  ->
  forall X, forall f:set -> set -> set, forall c:set, unpack_b_e (pack_b_e X f c) Phi = Phi X f c.
let Phi.
assume HPhi.
let X f c.
prove Phi (pack_b_e X f c 0) (decode_b (pack_b_e X f c 1)) (pack_b_e X f c 2) = Phi X f c.
rewrite <- struct_b_e_0_eq (pack_b_e X f c) X f c (eqI set (pack_b_e X f c)).
prove Phi X (decode_b (pack_b_e X f c 1)) (pack_b_e X f c 2) = Phi X f c.
rewrite <- struct_b_e_2_eq (pack_b_e X f c) X f c (eqI set (pack_b_e X f c)).
apply HPhi.
let x. assume Hx. let y. assume Hy.
prove decode_b (pack_b_e X f c 1) x y = f x y.
apply eq_sym set.
exact struct_b_e_1_eq (pack_b_e X f c) X f c (eqI set (pack_b_e X f c)) x Hx y Hy.
Qed.

End unpack_b_e.

Definition pack_u_u : set -> (set -> set) -> (set -> set) -> set := fun X i j => (X,encode_u X i,encode_u X j).

Definition struct_u_u : set -> prop := fun S => exists X:set, exists i:set -> set, exists j:set -> set, (forall x :e X, i x :e X) /\ (forall x :e X, j x :e X) /\ S = pack_u_u X i j.

Theorem pack_u_u_ext : forall X, forall i i':set -> set, forall j j':set -> set,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, j x = j' x) ->
 pack_u_u X i j = pack_u_u X i' j'.
let X i i' j j'. assume H1. assume H2.
prove (X,encode_u X i,encode_u X j) = (X,encode_u X i',encode_u X j').
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_u X j = encode_u X j'.
{ apply encode_u_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_u_u_0_eq: forall S X, forall i:set -> set, forall j:set -> set, S = pack_u_u X i j -> X = S 0.
let S X i j. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_u X j) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_u_u_1_eq: forall S X, forall i:set -> set, forall j:set -> set, S = pack_u_u X i j -> forall x :e X, i x = decode_u (S 1) x.
let S X i j. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_u X j) 1) x.
rewrite tuple_3_1_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_u_u_2_eq: forall S X, forall i:set -> set, forall j:set -> set, S = pack_u_u X i j -> forall x :e X, j x = decode_u (S 2) x.
let S X i j. assume H1.
let x. assume Hx. rewrite H1.
prove j x = decode_u ((X,encode_u X i,encode_u X j) 2) x.
rewrite tuple_3_2_eq.
apply eq_sym set. apply decode_encode_u X j x Hx.
Qed.

Theorem pack_struct_u_u: forall X, forall i:set -> set, forall j:set -> set, (forall x :e X, i x :e X) -> (forall x :e X, j x :e X) -> struct_u_u (pack_u_u X i j).
let X i j.
assume H1.
assume H2.
prove exists X':set, exists i':set -> set, exists j':set -> set,  (forall x :e X', i' x :e X') /\ (forall x :e X', j' x :e X') /\ pack_u_u X i j = pack_u_u X' i' j'.
witness X. witness i. witness j.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_u_u_eta: forall S, struct_u_u S -> S = pack_u_u (S 0) (decode_u (S 1)) (decode_u (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let i.
assume H2. apply H2. let j.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_u_u_0_eq S X i j Heq.
prove S = (X,encode_u X (decode_u (S 1)),encode_u X (decode_u (S 2))).
claim L1: encode_u X i = encode_u X (decode_u (S 1)).
{ apply encode_u_ext.
  exact struct_u_u_1_eq S X i j Heq.
}
rewrite <- L1.
claim L2: encode_u X j = encode_u X (decode_u (S 2)).
{ apply encode_u_ext.
  exact struct_u_u_2_eq S X i j Heq.
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_u_u.

Variable A:SType.

Definition unpack_u_u : set -> (set -> (set -> set) -> (set -> set) -> A) -> A := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_u (S 2)).

Theorem unpack_u_u_eq : forall Phi:set -> (set -> set) -> (set -> set) -> A,
  (forall X, forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall j j':set -> set, (forall x :e X, j x = j' x) -> Phi X i j = Phi X i' j')
  ->
  forall X, forall i:set -> set, forall j:set -> set, unpack_u_u (pack_u_u X i j) Phi = Phi X i j.
let Phi.
assume HPhi.
let X i j.
prove Phi (pack_u_u X i j 0) (decode_u (pack_u_u X i j 1)) (decode_u (pack_u_u X i j 2)) = Phi X i j.
rewrite <- struct_u_u_0_eq (pack_u_u X i j) X i j (eqI set (pack_u_u X i j)).
prove Phi X (decode_u (pack_u_u X i j 1)) (decode_u (pack_u_u X i j 2)) = Phi X i j.
apply HPhi.
- let x. assume Hx.
  prove decode_u (pack_u_u X i j 1) x = i x.
  apply eq_sym set.
  exact struct_u_u_1_eq (pack_u_u X i j) X i j (eqI set (pack_u_u X i j)) x Hx.
- let x. assume Hx.
  prove decode_u (pack_u_u X i j 2) x = j x.
  apply eq_sym set.
  exact struct_u_u_2_eq (pack_u_u X i j) X i j (eqI set (pack_u_u X i j)) x Hx.
Qed.

End unpack_u_u.

Definition pack_u_r : set -> (set -> set) -> (set -> set -> prop) -> set := fun X i R => (X,encode_u X i,encode_r X R).

Definition struct_u_r : set -> prop := fun S => exists X:set, exists i:set -> set, exists R:set -> set -> prop, (forall x :e X, i x :e X) /\ S = pack_u_r X i R.

Theorem pack_u_r_ext : forall X, forall i i':set -> set, forall R R':set -> set -> prop,
 (forall x :e X, i x = i' x) ->
 (forall x y :e X, R x y <-> R' x y) ->
 pack_u_r X i R = pack_u_r X i' R'.
let X i i' R R'. assume H1. assume H2.
prove (X,encode_u X i,encode_r X R) = (X,encode_u X i',encode_r X R').
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_u_r_0_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, S = pack_u_r X i R -> X = S 0.
let S X i R. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_r X R) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_u_r_1_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, S = pack_u_r X i R -> forall x :e X, i x = decode_u (S 1) x.
let S X i R. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_r X R) 1) x.
rewrite tuple_3_1_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_u_r_2_eq: forall S X, forall i:set -> set, forall R:set -> set -> prop, S = pack_u_r X i R -> forall x y :e X, R x y = decode_r (S 2) x y.
let S X i R. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_u X i,encode_r X R) 2) x y.
rewrite tuple_3_2_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem pack_struct_u_r: forall X, forall i:set -> set, forall R:set -> set -> prop, (forall x :e X, i x :e X) -> struct_u_r (pack_u_r X i R).
let X i R.
assume H1.
prove exists X':set, exists i':set -> set, exists R':set -> set -> prop,  (forall x :e X', i' x :e X') /\ pack_u_r X i R = pack_u_r X' i' R'.
witness X. witness i. witness R.
apply andI.
exact H1.
apply eqI set.
Qed.

Theorem struct_u_r_eta: forall S, struct_u_r S -> S = pack_u_r (S 0) (decode_u (S 1)) (decode_r (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let i.
assume H2. apply H2. let R.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_u_r_0_eq S X i R Heq.
prove S = (X,encode_u X (decode_u (S 1)),encode_r X (decode_r (S 2))).
claim L1: encode_u X i = encode_u X (decode_u (S 1)).
{ apply encode_u_ext.
  exact struct_u_r_1_eq S X i R Heq.
}
rewrite <- L1.
claim L2: encode_r X R = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_u_r_2_eq S X i R Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_u_r.

Variable A:SType.

Definition unpack_u_r : set -> (set -> (set -> set) -> (set -> set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_r (S 2)).

Theorem unpack_u_r_eq : forall Phi:set -> (set -> set) -> (set -> set -> prop) -> A,
  (forall X, forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) -> Phi X i R = Phi X i' R')
  ->
  forall X, forall i:set -> set, forall R:set -> set -> prop, unpack_u_r (pack_u_r X i R) Phi = Phi X i R.
let Phi.
assume HPhi.
let X i R.
prove Phi (pack_u_r X i R 0) (decode_u (pack_u_r X i R 1)) (decode_r (pack_u_r X i R 2)) = Phi X i R.
rewrite <- struct_u_r_0_eq (pack_u_r X i R) X i R (eqI set (pack_u_r X i R)).
prove Phi X (decode_u (pack_u_r X i R 1)) (decode_r (pack_u_r X i R 2)) = Phi X i R.
apply HPhi.
- let x. assume Hx.
  prove decode_u (pack_u_r X i R 1) x = i x.
  apply eq_sym set.
  exact struct_u_r_1_eq (pack_u_r X i R) X i R (eqI set (pack_u_r X i R)) x Hx.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_u_r X i R 2) x y <-> R x y.
  rewrite <- struct_u_r_2_eq (pack_u_r X i R) X i R (eqI set (pack_u_r X i R)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_u_r.

Definition pack_u_p : set -> (set -> set) -> (set -> prop) -> set := fun X i P => (X,encode_u X i,encode_p X P).

Definition struct_u_p : set -> prop := fun S => exists X:set, exists i:set -> set, exists P:set -> prop, (forall x :e X, i x :e X) /\ S = pack_u_p X i P.

Theorem pack_u_p_ext : forall X, forall i i':set -> set, forall P P':set -> prop,
 (forall x :e X, i x = i' x) ->
 (forall x :e X, P x <-> P' x) ->
 pack_u_p X i P = pack_u_p X i' P'.
let X i i' P P'. assume H1. assume H2.
prove (X,encode_u X i,encode_p X P) = (X,encode_u X i',encode_p X P').
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
claim L2: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_u_p_0_eq: forall S X, forall i:set -> set, forall P:set -> prop, S = pack_u_p X i P -> X = S 0.
let S X i P. assume H1. rewrite H1.
prove X = (X,encode_u X i,encode_p X P) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_u_p_1_eq: forall S X, forall i:set -> set, forall P:set -> prop, S = pack_u_p X i P -> forall x :e X, i x = decode_u (S 1) x.
let S X i P. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,encode_p X P) 1) x.
rewrite tuple_3_1_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_u_p_2_eq: forall S X, forall i:set -> set, forall P:set -> prop, S = pack_u_p X i P -> forall x :e X, P x = decode_p (S 2) x.
let S X i P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_u X i,encode_p X P) 2) x.
rewrite tuple_3_2_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_u_p: forall X, forall i:set -> set, forall P:set -> prop, (forall x :e X, i x :e X) -> struct_u_p (pack_u_p X i P).
let X i P.
assume H1.
prove exists X':set, exists i':set -> set, exists P':set -> prop,  (forall x :e X', i' x :e X') /\ pack_u_p X i P = pack_u_p X' i' P'.
witness X. witness i. witness P.
apply andI.
exact H1.
apply eqI set.
Qed.

Theorem struct_u_p_eta: forall S, struct_u_p S -> S = pack_u_p (S 0) (decode_u (S 1)) (decode_p (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let i.
assume H2. apply H2. let P.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_u_p_0_eq S X i P Heq.
prove S = (X,encode_u X (decode_u (S 1)),encode_p X (decode_p (S 2))).
claim L1: encode_u X i = encode_u X (decode_u (S 1)).
{ apply encode_u_ext.
  exact struct_u_p_1_eq S X i P Heq.
}
rewrite <- L1.
claim L2: encode_p X P = encode_p X (decode_p (S 2)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_u_p_2_eq S X i P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_u_p.

Variable A:SType.

Definition unpack_u_p : set -> (set -> (set -> set) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_u (S 1)) (decode_p (S 2)).

Theorem unpack_u_p_eq : forall Phi:set -> (set -> set) -> (set -> prop) -> A,
  (forall X, forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X i P = Phi X i' P')
  ->
  forall X, forall i:set -> set, forall P:set -> prop, unpack_u_p (pack_u_p X i P) Phi = Phi X i P.
let Phi.
assume HPhi.
let X i P.
prove Phi (pack_u_p X i P 0) (decode_u (pack_u_p X i P 1)) (decode_p (pack_u_p X i P 2)) = Phi X i P.
rewrite <- struct_u_p_0_eq (pack_u_p X i P) X i P (eqI set (pack_u_p X i P)).
prove Phi X (decode_u (pack_u_p X i P 1)) (decode_p (pack_u_p X i P 2)) = Phi X i P.
apply HPhi.
- let x. assume Hx.
  prove decode_u (pack_u_p X i P 1) x = i x.
  apply eq_sym set.
  exact struct_u_p_1_eq (pack_u_p X i P) X i P (eqI set (pack_u_p X i P)) x Hx.
- let x. assume Hx.
  prove decode_p (pack_u_p X i P 2) x <-> P x.
  rewrite <- struct_u_p_2_eq (pack_u_p X i P) X i P (eqI set (pack_u_p X i P)) x Hx.
  apply iff_refl.
Qed.

End unpack_u_p.

Definition pack_u_e : set -> (set -> set) -> set -> set := fun X i c => (X,encode_u X i,c).

Definition struct_u_e : set -> prop := fun S => exists X:set, exists i:set -> set, exists c:set, (forall x :e X, i x :e X) /\ c :e X /\ S = pack_u_e X i c.

Theorem pack_u_e_ext : forall X, forall i i':set -> set, forall c,
 (forall x :e X, i x = i' x) ->
 pack_u_e X i c = pack_u_e X i' c.
let X i i' c. assume H1.
prove (X,encode_u X i,c) = (X,encode_u X i',c).
claim L1: encode_u X i = encode_u X i'.
{ apply encode_u_ext. exact H1. }
rewrite <- L1.
apply eqI set.
Qed.

Theorem struct_u_e_0_eq: forall S X, forall i:set -> set, forall c:set, S = pack_u_e X i c -> X = S 0.
let S X i c. assume H1. rewrite H1.
prove X = (X,encode_u X i,c) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_u_e_1_eq: forall S X, forall i:set -> set, forall c:set, S = pack_u_e X i c -> forall x :e X, i x = decode_u (S 1) x.
let S X i c. assume H1.
let x. assume Hx. rewrite H1.
prove i x = decode_u ((X,encode_u X i,c) 1) x.
rewrite tuple_3_1_eq.
apply eq_sym set. apply decode_encode_u X i x Hx.
Qed.

Theorem struct_u_e_2_eq: forall S X, forall i:set -> set, forall c:set, S = pack_u_e X i c -> c = S 2.
let S X i c. assume H1.
rewrite H1. prove c = (X,encode_u X i,c) 2. apply eq_sym set. apply tuple_3_2_eq.
Qed.

Theorem pack_struct_u_e: forall X, forall i:set -> set, forall c:set, (forall x :e X, i x :e X) -> c :e X -> struct_u_e (pack_u_e X i c).
let X i c.
assume H1.
assume H2.
prove exists X':set, exists i':set -> set, exists c':set,  (forall x :e X', i' x :e X') /\ c' :e X' /\ pack_u_e X i c = pack_u_e X' i' c'.
witness X. witness i. witness c.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_u_e_eta: forall S, struct_u_e S -> S = pack_u_e (S 0) (decode_u (S 1)) (S 2).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let i.
assume H2. apply H2. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_u_e_0_eq S X i c Heq.
prove S = (X,encode_u X (decode_u (S 1)),S 2).
claim L1: encode_u X i = encode_u X (decode_u (S 1)).
{ apply encode_u_ext.
  exact struct_u_e_1_eq S X i c Heq.
}
rewrite <- L1.
claim L2: c = (S 2).
{ exact struct_u_e_2_eq S X i c Heq. }
rewrite <- L2.
exact Heq.
Qed.

Section unpack_u_e.

Variable A:SType.

Definition unpack_u_e : set -> (set -> (set -> set) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_u (S 1)) (S 2).

Theorem unpack_u_e_eq : forall Phi:set -> (set -> set) -> set -> A,
  (forall X, forall i i':set -> set, (forall x :e X, i x = i' x) ->  forall c,Phi X i c = Phi X i' c)
  ->
  forall X, forall i:set -> set, forall c:set, unpack_u_e (pack_u_e X i c) Phi = Phi X i c.
let Phi.
assume HPhi.
let X i c.
prove Phi (pack_u_e X i c 0) (decode_u (pack_u_e X i c 1)) (pack_u_e X i c 2) = Phi X i c.
rewrite <- struct_u_e_0_eq (pack_u_e X i c) X i c (eqI set (pack_u_e X i c)).
prove Phi X (decode_u (pack_u_e X i c 1)) (pack_u_e X i c 2) = Phi X i c.
rewrite <- struct_u_e_2_eq (pack_u_e X i c) X i c (eqI set (pack_u_e X i c)).
apply HPhi.
let x. assume Hx.
prove decode_u (pack_u_e X i c 1) x = i x.
apply eq_sym set.
exact struct_u_e_1_eq (pack_u_e X i c) X i c (eqI set (pack_u_e X i c)) x Hx.
Qed.

End unpack_u_e.

Definition pack_r_r : set -> (set -> set -> prop) -> (set -> set -> prop) -> set := fun X R T => (X,encode_r X R,encode_r X T).

Definition struct_r_r : set -> prop := fun S => exists X:set, exists R:set -> set -> prop, exists T:set -> set -> prop, S = pack_r_r X R T.

Theorem pack_r_r_ext : forall X, forall R R':set -> set -> prop, forall T T':set -> set -> prop,
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x y :e X, T x y <-> T' x y) ->
 pack_r_r X R T = pack_r_r X R' T'.
let X R R' T T'. assume H1. assume H2.
prove (X,encode_r X R,encode_r X T) = (X,encode_r X R',encode_r X T').
claim L1: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H1. }
rewrite <- L1.
claim L2: encode_r X T = encode_r X T'.
{ apply encode_r_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_r_r_0_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_r_r X R T -> X = S 0.
let S X R T. assume H1. rewrite H1.
prove X = (X,encode_r X R,encode_r X T) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_r_r_1_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_r_r X R T -> forall x y :e X, R x y = decode_r (S 1) x y.
let S X R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_r X R,encode_r X T) 1) x y.
rewrite tuple_3_1_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_r_r_2_eq: forall S X, forall R:set -> set -> prop, forall T:set -> set -> prop, S = pack_r_r X R T -> forall x y :e X, T x y = decode_r (S 2) x y.
let S X R T. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove T x y = decode_r ((X,encode_r X R,encode_r X T) 2) x y.
rewrite tuple_3_2_eq.
apply eq_sym prop. exact decode_encode_r X T x Hx y Hy.
Qed.

Theorem pack_struct_r_r: forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, struct_r_r (pack_r_r X R T).
let X R T.
prove exists X':set, exists R':set -> set -> prop, exists T':set -> set -> prop,  pack_r_r X R T = pack_r_r X' R' T'.
witness X. witness R. witness T.
apply eqI set.
Qed.

Theorem struct_r_r_eta: forall S, struct_r_r S -> S = pack_r_r (S 0) (decode_r (S 1)) (decode_r (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let R.
assume H2. apply H2. let T.
assume Heq.
rewrite <- struct_r_r_0_eq S X R T Heq.
prove S = (X,encode_r X (decode_r (S 1)),encode_r X (decode_r (S 2))).
claim L1: encode_r X R = encode_r X (decode_r (S 1)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_r_r_1_eq S X R T Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L1.
claim L2: encode_r X T = encode_r X (decode_r (S 2)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_r_r_2_eq S X R T Heq x Hx y Hy.
  exact iff_refl (T x y).
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_r_r.

Variable A:SType.

Definition unpack_r_r : set -> (set -> (set -> set -> prop) -> (set -> set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_r (S 1)) (decode_r (S 2)).

Theorem unpack_r_r_eq : forall Phi:set -> (set -> set -> prop) -> (set -> set -> prop) -> A,
  (forall X, forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall T T':set -> set -> prop, (forall x y :e X, T x y <-> T' x y) -> Phi X R T = Phi X R' T')
  ->
  forall X, forall R:set -> set -> prop, forall T:set -> set -> prop, unpack_r_r (pack_r_r X R T) Phi = Phi X R T.
let Phi.
assume HPhi.
let X R T.
prove Phi (pack_r_r X R T 0) (decode_r (pack_r_r X R T 1)) (decode_r (pack_r_r X R T 2)) = Phi X R T.
rewrite <- struct_r_r_0_eq (pack_r_r X R T) X R T (eqI set (pack_r_r X R T)).
prove Phi X (decode_r (pack_r_r X R T 1)) (decode_r (pack_r_r X R T 2)) = Phi X R T.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_r_r X R T 1) x y <-> R x y.
  rewrite <- struct_r_r_1_eq (pack_r_r X R T) X R T (eqI set (pack_r_r X R T)) x Hx y Hy.
  apply iff_refl.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_r_r X R T 2) x y <-> T x y.
  rewrite <- struct_r_r_2_eq (pack_r_r X R T) X R T (eqI set (pack_r_r X R T)) x Hx y Hy.
  apply iff_refl.
Qed.

End unpack_r_r.

Definition pack_r_p : set -> (set -> set -> prop) -> (set -> prop) -> set := fun X R P => (X,encode_r X R,encode_p X P).

Definition struct_r_p : set -> prop := fun S => exists X:set, exists R:set -> set -> prop, exists P:set -> prop, S = pack_r_p X R P.

Theorem pack_r_p_ext : forall X, forall R R':set -> set -> prop, forall P P':set -> prop,
 (forall x y :e X, R x y <-> R' x y) ->
 (forall x :e X, P x <-> P' x) ->
 pack_r_p X R P = pack_r_p X R' P'.
let X R R' P P'. assume H1. assume H2.
prove (X,encode_r X R,encode_p X P) = (X,encode_r X R',encode_p X P').
claim L1: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H1. }
rewrite <- L1.
claim L2: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_r_p_0_eq: forall S X, forall R:set -> set -> prop, forall P:set -> prop, S = pack_r_p X R P -> X = S 0.
let S X R P. assume H1. rewrite H1.
prove X = (X,encode_r X R,encode_p X P) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_r_p_1_eq: forall S X, forall R:set -> set -> prop, forall P:set -> prop, S = pack_r_p X R P -> forall x y :e X, R x y = decode_r (S 1) x y.
let S X R P. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_r X R,encode_p X P) 1) x y.
rewrite tuple_3_1_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_r_p_2_eq: forall S X, forall R:set -> set -> prop, forall P:set -> prop, S = pack_r_p X R P -> forall x :e X, P x = decode_p (S 2) x.
let S X R P. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_r X R,encode_p X P) 2) x.
rewrite tuple_3_2_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem pack_struct_r_p: forall X, forall R:set -> set -> prop, forall P:set -> prop, struct_r_p (pack_r_p X R P).
let X R P.
prove exists X':set, exists R':set -> set -> prop, exists P':set -> prop,  pack_r_p X R P = pack_r_p X' R' P'.
witness X. witness R. witness P.
apply eqI set.
Qed.

Theorem struct_r_p_eta: forall S, struct_r_p S -> S = pack_r_p (S 0) (decode_r (S 1)) (decode_p (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let R.
assume H2. apply H2. let P.
assume Heq.
rewrite <- struct_r_p_0_eq S X R P Heq.
prove S = (X,encode_r X (decode_r (S 1)),encode_p X (decode_p (S 2))).
claim L1: encode_r X R = encode_r X (decode_r (S 1)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_r_p_1_eq S X R P Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L1.
claim L2: encode_p X P = encode_p X (decode_p (S 2)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_r_p_2_eq S X R P Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_r_p.

Variable A:SType.

Definition unpack_r_p : set -> (set -> (set -> set -> prop) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_r (S 1)) (decode_p (S 2)).

Theorem unpack_r_p_eq : forall Phi:set -> (set -> set -> prop) -> (set -> prop) -> A,
  (forall X, forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall P P':set -> prop, (forall x :e X, P x <-> P' x) -> Phi X R P = Phi X R' P')
  ->
  forall X, forall R:set -> set -> prop, forall P:set -> prop, unpack_r_p (pack_r_p X R P) Phi = Phi X R P.
let Phi.
assume HPhi.
let X R P.
prove Phi (pack_r_p X R P 0) (decode_r (pack_r_p X R P 1)) (decode_p (pack_r_p X R P 2)) = Phi X R P.
rewrite <- struct_r_p_0_eq (pack_r_p X R P) X R P (eqI set (pack_r_p X R P)).
prove Phi X (decode_r (pack_r_p X R P 1)) (decode_p (pack_r_p X R P 2)) = Phi X R P.
apply HPhi.
- let x. assume Hx. let y. assume Hy.
  prove decode_r (pack_r_p X R P 1) x y <-> R x y.
  rewrite <- struct_r_p_1_eq (pack_r_p X R P) X R P (eqI set (pack_r_p X R P)) x Hx y Hy.
  apply iff_refl.
- let x. assume Hx.
  prove decode_p (pack_r_p X R P 2) x <-> P x.
  rewrite <- struct_r_p_2_eq (pack_r_p X R P) X R P (eqI set (pack_r_p X R P)) x Hx.
  apply iff_refl.
Qed.

End unpack_r_p.

Definition pack_r_e : set -> (set -> set -> prop) -> set -> set := fun X R c => (X,encode_r X R,c).

Definition struct_r_e : set -> prop := fun S => exists X:set, exists R:set -> set -> prop, exists c:set, c :e X /\ S = pack_r_e X R c.

Theorem pack_r_e_ext : forall X, forall R R':set -> set -> prop, forall c,
 (forall x y :e X, R x y <-> R' x y) ->
 pack_r_e X R c = pack_r_e X R' c.
let X R R' c. assume H1.
prove (X,encode_r X R,c) = (X,encode_r X R',c).
claim L1: encode_r X R = encode_r X R'.
{ apply encode_r_ext. exact H1. }
rewrite <- L1.
apply eqI set.
Qed.

Theorem struct_r_e_0_eq: forall S X, forall R:set -> set -> prop, forall c:set, S = pack_r_e X R c -> X = S 0.
let S X R c. assume H1. rewrite H1.
prove X = (X,encode_r X R,c) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_r_e_1_eq: forall S X, forall R:set -> set -> prop, forall c:set, S = pack_r_e X R c -> forall x y :e X, R x y = decode_r (S 1) x y.
let S X R c. assume H1.
let x. assume Hx. let y. assume Hy. rewrite H1.
prove R x y = decode_r ((X,encode_r X R,c) 1) x y.
rewrite tuple_3_1_eq.
apply eq_sym prop. exact decode_encode_r X R x Hx y Hy.
Qed.

Theorem struct_r_e_2_eq: forall S X, forall R:set -> set -> prop, forall c:set, S = pack_r_e X R c -> c = S 2.
let S X R c. assume H1.
rewrite H1. prove c = (X,encode_r X R,c) 2. apply eq_sym set. apply tuple_3_2_eq.
Qed.

Theorem pack_struct_r_e: forall X, forall R:set -> set -> prop, forall c:set, c :e X -> struct_r_e (pack_r_e X R c).
let X R c.
assume H2.
prove exists X':set, exists R':set -> set -> prop, exists c':set,  c' :e X' /\ pack_r_e X R c = pack_r_e X' R' c'.
witness X. witness R. witness c.
apply andI.
exact H2.
apply eqI set.
Qed.

Theorem struct_r_e_eta: forall S, struct_r_e S -> S = pack_r_e (S 0) (decode_r (S 1)) (S 2).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let R.
assume H2. apply H2. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_r_e_0_eq S X R c Heq.
prove S = (X,encode_r X (decode_r (S 1)),S 2).
claim L1: encode_r X R = encode_r X (decode_r (S 1)).
{ apply encode_r_ext.
  let x. assume Hx. let y. assume Hy.
  rewrite <- struct_r_e_1_eq S X R c Heq x Hx y Hy.
  exact iff_refl (R x y).
}
rewrite <- L1.
claim L2: c = (S 2).
{ exact struct_r_e_2_eq S X R c Heq. }
rewrite <- L2.
exact Heq.
Qed.

Section unpack_r_e.

Variable A:SType.

Definition unpack_r_e : set -> (set -> (set -> set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_r (S 1)) (S 2).

Theorem unpack_r_e_eq : forall Phi:set -> (set -> set -> prop) -> set -> A,
  (forall X, forall R R':set -> set -> prop, (forall x y :e X, R x y <-> R' x y) ->  forall c,Phi X R c = Phi X R' c)
  ->
  forall X, forall R:set -> set -> prop, forall c:set, unpack_r_e (pack_r_e X R c) Phi = Phi X R c.
let Phi.
assume HPhi.
let X R c.
prove Phi (pack_r_e X R c 0) (decode_r (pack_r_e X R c 1)) (pack_r_e X R c 2) = Phi X R c.
rewrite <- struct_r_e_0_eq (pack_r_e X R c) X R c (eqI set (pack_r_e X R c)).
prove Phi X (decode_r (pack_r_e X R c 1)) (pack_r_e X R c 2) = Phi X R c.
rewrite <- struct_r_e_2_eq (pack_r_e X R c) X R c (eqI set (pack_r_e X R c)).
apply HPhi.
let x. assume Hx. let y. assume Hy.
prove decode_r (pack_r_e X R c 1) x y <-> R x y.
rewrite <- struct_r_e_1_eq (pack_r_e X R c) X R c (eqI set (pack_r_e X R c)) x Hx y Hy.
apply iff_refl.
Qed.

End unpack_r_e.

Definition pack_p_p : set -> (set -> prop) -> (set -> prop) -> set := fun X P Q => (X,encode_p X P,encode_p X Q).

Definition struct_p_p : set -> prop := fun S => exists X:set, exists P:set -> prop, exists Q:set -> prop, S = pack_p_p X P Q.

Theorem pack_p_p_ext : forall X, forall P P':set -> prop, forall Q Q':set -> prop,
 (forall x :e X, P x <-> P' x) ->
 (forall x :e X, Q x <-> Q' x) ->
 pack_p_p X P Q = pack_p_p X P' Q'.
let X P P' Q Q'. assume H1. assume H2.
prove (X,encode_p X P,encode_p X Q) = (X,encode_p X P',encode_p X Q').
claim L1: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H1. }
rewrite <- L1.
claim L2: encode_p X Q = encode_p X Q'.
{ apply encode_p_ext. exact H2. }
rewrite <- L2.
apply eqI set.
Qed.

Theorem struct_p_p_0_eq: forall S X, forall P:set -> prop, forall Q:set -> prop, S = pack_p_p X P Q -> X = S 0.
let S X P Q. assume H1. rewrite H1.
prove X = (X,encode_p X P,encode_p X Q) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_p_p_1_eq: forall S X, forall P:set -> prop, forall Q:set -> prop, S = pack_p_p X P Q -> forall x :e X, P x = decode_p (S 1) x.
let S X P Q. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_p X P,encode_p X Q) 1) x.
rewrite tuple_3_1_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem struct_p_p_2_eq: forall S X, forall P:set -> prop, forall Q:set -> prop, S = pack_p_p X P Q -> forall x :e X, Q x = decode_p (S 2) x.
let S X P Q. assume H1.
let x. assume Hx. rewrite H1.
prove Q x = decode_p ((X,encode_p X P,encode_p X Q) 2) x.
rewrite tuple_3_2_eq.
apply eq_sym prop. exact decode_encode_p X Q x Hx.
Qed.

Theorem pack_struct_p_p: forall X, forall P:set -> prop, forall Q:set -> prop, struct_p_p (pack_p_p X P Q).
let X P Q.
prove exists X':set, exists P':set -> prop, exists Q':set -> prop,  pack_p_p X P Q = pack_p_p X' P' Q'.
witness X. witness P. witness Q.
apply eqI set.
Qed.

Theorem struct_p_p_eta: forall S, struct_p_p S -> S = pack_p_p (S 0) (decode_p (S 1)) (decode_p (S 2)).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let P.
assume H2. apply H2. let Q.
assume Heq.
rewrite <- struct_p_p_0_eq S X P Q Heq.
prove S = (X,encode_p X (decode_p (S 1)),encode_p X (decode_p (S 2))).
claim L1: encode_p X P = encode_p X (decode_p (S 1)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_p_p_1_eq S X P Q Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L1.
claim L2: encode_p X Q = encode_p X (decode_p (S 2)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_p_p_2_eq S X P Q Heq x Hx.
  exact iff_refl (Q x).
}
rewrite <- L2.
exact Heq.
Qed.

Section unpack_p_p.

Variable A:SType.

Definition unpack_p_p : set -> (set -> (set -> prop) -> (set -> prop) -> A) -> A := fun S Phi => Phi (S 0) (decode_p (S 1)) (decode_p (S 2)).

Theorem unpack_p_p_eq : forall Phi:set -> (set -> prop) -> (set -> prop) -> A,
  (forall X, forall P P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall Q Q':set -> prop, (forall x :e X, Q x <-> Q' x) -> Phi X P Q = Phi X P' Q')
  ->
  forall X, forall P:set -> prop, forall Q:set -> prop, unpack_p_p (pack_p_p X P Q) Phi = Phi X P Q.
let Phi.
assume HPhi.
let X P Q.
prove Phi (pack_p_p X P Q 0) (decode_p (pack_p_p X P Q 1)) (decode_p (pack_p_p X P Q 2)) = Phi X P Q.
rewrite <- struct_p_p_0_eq (pack_p_p X P Q) X P Q (eqI set (pack_p_p X P Q)).
prove Phi X (decode_p (pack_p_p X P Q 1)) (decode_p (pack_p_p X P Q 2)) = Phi X P Q.
apply HPhi.
- let x. assume Hx.
  prove decode_p (pack_p_p X P Q 1) x <-> P x.
  rewrite <- struct_p_p_1_eq (pack_p_p X P Q) X P Q (eqI set (pack_p_p X P Q)) x Hx.
  apply iff_refl.
- let x. assume Hx.
  prove decode_p (pack_p_p X P Q 2) x <-> Q x.
  rewrite <- struct_p_p_2_eq (pack_p_p X P Q) X P Q (eqI set (pack_p_p X P Q)) x Hx.
  apply iff_refl.
Qed.

End unpack_p_p.

Definition pack_p_e : set -> (set -> prop) -> set -> set := fun X P c => (X,encode_p X P,c).

Definition struct_p_e : set -> prop := fun S => exists X:set, exists P:set -> prop, exists c:set, c :e X /\ S = pack_p_e X P c.

Theorem pack_p_e_ext : forall X, forall P P':set -> prop, forall c,
 (forall x :e X, P x <-> P' x) ->
 pack_p_e X P c = pack_p_e X P' c.
let X P P' c. assume H1.
prove (X,encode_p X P,c) = (X,encode_p X P',c).
claim L1: encode_p X P = encode_p X P'.
{ apply encode_p_ext. exact H1. }
rewrite <- L1.
apply eqI set.
Qed.

Theorem struct_p_e_0_eq: forall S X, forall P:set -> prop, forall c:set, S = pack_p_e X P c -> X = S 0.
let S X P c. assume H1. rewrite H1.
prove X = (X,encode_p X P,c) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_p_e_1_eq: forall S X, forall P:set -> prop, forall c:set, S = pack_p_e X P c -> forall x :e X, P x = decode_p (S 1) x.
let S X P c. assume H1.
let x. assume Hx. rewrite H1.
prove P x = decode_p ((X,encode_p X P,c) 1) x.
rewrite tuple_3_1_eq.
apply eq_sym prop. exact decode_encode_p X P x Hx.
Qed.

Theorem struct_p_e_2_eq: forall S X, forall P:set -> prop, forall c:set, S = pack_p_e X P c -> c = S 2.
let S X P c. assume H1.
rewrite H1. prove c = (X,encode_p X P,c) 2. apply eq_sym set. apply tuple_3_2_eq.
Qed.

Theorem pack_struct_p_e: forall X, forall P:set -> prop, forall c:set, c :e X -> struct_p_e (pack_p_e X P c).
let X P c.
assume H2.
prove exists X':set, exists P':set -> prop, exists c':set,  c' :e X' /\ pack_p_e X P c = pack_p_e X' P' c'.
witness X. witness P. witness c.
apply andI.
exact H2.
apply eqI set.
Qed.

Theorem struct_p_e_eta: forall S, struct_p_e S -> S = pack_p_e (S 0) (decode_p (S 1)) (S 2).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let P.
assume H2. apply H2. let c.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_p_e_0_eq S X P c Heq.
prove S = (X,encode_p X (decode_p (S 1)),S 2).
claim L1: encode_p X P = encode_p X (decode_p (S 1)).
{ apply encode_p_ext.
  let x. assume Hx.
  rewrite <- struct_p_e_1_eq S X P c Heq x Hx.
  exact iff_refl (P x).
}
rewrite <- L1.
claim L2: c = (S 2).
{ exact struct_p_e_2_eq S X P c Heq. }
rewrite <- L2.
exact Heq.
Qed.

Section unpack_p_e.

Variable A:SType.

Definition unpack_p_e : set -> (set -> (set -> prop) -> set -> A) -> A := fun S Phi => Phi (S 0) (decode_p (S 1)) (S 2).

Theorem unpack_p_e_eq : forall Phi:set -> (set -> prop) -> set -> A,
  (forall X, forall P P':set -> prop, (forall x :e X, P x <-> P' x) ->  forall c,Phi X P c = Phi X P' c)
  ->
  forall X, forall P:set -> prop, forall c:set, unpack_p_e (pack_p_e X P c) Phi = Phi X P c.
let Phi.
assume HPhi.
let X P c.
prove Phi (pack_p_e X P c 0) (decode_p (pack_p_e X P c 1)) (pack_p_e X P c 2) = Phi X P c.
rewrite <- struct_p_e_0_eq (pack_p_e X P c) X P c (eqI set (pack_p_e X P c)).
prove Phi X (decode_p (pack_p_e X P c 1)) (pack_p_e X P c 2) = Phi X P c.
rewrite <- struct_p_e_2_eq (pack_p_e X P c) X P c (eqI set (pack_p_e X P c)).
apply HPhi.
let x. assume Hx.
prove decode_p (pack_p_e X P c 1) x <-> P x.
rewrite <- struct_p_e_1_eq (pack_p_e X P c) X P c (eqI set (pack_p_e X P c)) x Hx.
apply iff_refl.
Qed.

End unpack_p_e.

Definition pack_e_e : set -> set -> set -> set := fun X c d => (X,c,d).

Definition struct_e_e : set -> prop := fun S => exists X:set, exists c:set, exists d:set, c :e X /\ d :e X /\ S = pack_e_e X c d.

Theorem struct_e_e_0_eq: forall S X, forall c:set, forall d:set, S = pack_e_e X c d -> X = S 0.
let S X c d. assume H1. rewrite H1.
prove X = (X,c,d) 0.
apply eq_sym set. apply tuple_3_0_eq.
Qed.

Theorem struct_e_e_1_eq: forall S X, forall c:set, forall d:set, S = pack_e_e X c d -> c = S 1.
let S X c d. assume H1.
rewrite H1. prove c = (X,c,d) 1. apply eq_sym set. apply tuple_3_1_eq.
Qed.

Theorem struct_e_e_2_eq: forall S X, forall c:set, forall d:set, S = pack_e_e X c d -> d = S 2.
let S X c d. assume H1.
rewrite H1. prove d = (X,c,d) 2. apply eq_sym set. apply tuple_3_2_eq.
Qed.

Theorem pack_struct_e_e: forall X, forall c:set, forall d:set, c :e X -> d :e X -> struct_e_e (pack_e_e X c d).
let X c d.
assume H1.
assume H2.
prove exists X':set, exists c':set, exists d':set,  c' :e X' /\ d' :e X' /\ pack_e_e X c d = pack_e_e X' c' d'.
witness X. witness c. witness d.
apply andI.
apply andI.
exact H1.
exact H2.
apply eqI set.
Qed.

Theorem struct_e_e_eta: forall S, struct_e_e S -> S = pack_e_e (S 0) (S 1) (S 2).
let S.
assume H0. apply H0. let X.
assume H1. apply H1. let c.
assume H2. apply H2. let d.
assume H. apply H. assume _.
assume Heq.
rewrite <- struct_e_e_0_eq S X c d Heq.
prove S = (X,S 1,S 2).
claim L1: c = (S 1).
{ exact struct_e_e_1_eq S X c d Heq. }
rewrite <- L1.
claim L2: d = (S 2).
{ exact struct_e_e_2_eq S X c d Heq. }
rewrite <- L2.
exact Heq.
Qed.

Section unpack_e_e.

Variable A:SType.

Definition unpack_e_e : set -> (set -> set -> set -> A) -> A := fun S Phi => Phi (S 0) (S 1) (S 2).

Theorem unpack_e_e_eq : forall Phi:set -> set -> set -> A,
  forall X, forall c:set, forall d:set, unpack_e_e (pack_e_e X c d) Phi = Phi X c d.
let Phi.
let X c d.
prove Phi (pack_e_e X c d 0) (pack_e_e X c d 1) (pack_e_e X c d 2) = Phi X c d.
rewrite <- struct_e_e_0_eq (pack_e_e X c d) X c d (eqI set (pack_e_e X c d)).
prove Phi X (pack_e_e X c d 1) (pack_e_e X c d 2) = Phi X c d.
rewrite <- struct_e_e_1_eq (pack_e_e X c d) X c d (eqI set (pack_e_e X c d)).
rewrite <- struct_e_e_2_eq (pack_e_e X c d) X c d (eqI set (pack_e_e X c d)).
exact eqI A (Phi X c d).
Qed.

End unpack_e_e.
